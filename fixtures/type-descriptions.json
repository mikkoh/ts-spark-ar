{
  "enums":[
     {
        "name":"TextAlignment",
        "scope":"SceneModule",
        "description":"The `TextAlignment` enum describes how a text element is aligned horizontally.",
        "values":[
           {
              "description":"Indicates that the text is right-justified.",
              "name":"RIGHT"
           },
           {
              "description":"Indicates that the text is centered.",
              "name":"CENTER"
           },
           {
              "description":"Indicates that the text is left-justified.",
              "name":"LEFT"
           }
        ]
     },
     {
        "name":"VerticalTextAlignment",
        "scope":"SceneModule",
        "description":"The `VerticalTextAlignment` enum describes how a text element is aligned vertically.",
        "values":[
           {
              "description":"Indicates that the text is aligned at the bottom of the container.",
              "name":"BOTTOM"
           },
           {
              "description":"Indicates that the text is aligned at the center of the container.",
              "name":"CENTER"
           },
           {
              "description":"Indicates that the text is aligned at the top of the container.",
              "name":"TOP"
           }
        ]
     },
     {
        "name":"BrushType",
        "scope":"SceneModule.DynamicExtrusion",
        "description":"The `BrushType` enum describes what kind of brush is used for dynamic extrusion.",
        "values":[
           {
              "description":"Indicates the flat brush type.",
              "name":"FLAT"
           },
           {
              "description":"Indicates the hexagon brush type.",
              "name":"HEXAGON"
           },
           {
              "description":"Indicates the triangle brush type.",
              "name":"TRIANGLE"
           },
           {
              "description":"Indicates the quad brush type.",
              "name":"QUAD"
           }
        ]
     },
     {
        "name":"AntiderivativeOverflowBehaviour",
        "scope":"ReactiveModule",
        "description":"The `AntiderivativeOverflowBehaviour` enum describes the recovery technique used when an antiderivative overflows.",
        "values":[
           {
              "description":"Start from the other end of the interval (min,max)",
              "name":"WRAP"
           },
           {
              "description":"Clamp to either min and max",
              "name":"CLAMP"
           }
        ]
     },
     {
        "name":"HorizontalAlignment",
        "scope":"SceneModule",
        "description":"The `HorizontalAlignment` enum describes how an element is aligned horizontally.",
        "values":[
           {
              "description":"Indicates that the element is right justified.",
              "name":"RIGHT"
           },
           {
              "description":"Indicates that the element is centered.",
              "name":"CENTER"
           },
           {
              "description":"Indicates that the element is left justified.",
              "name":"LEFT"
           }
        ]
     },
     {
        "name":"TrackingMode",
        "scope":"SceneModule",
        "description":"The `TrackingMode` enum describes how a PlaneTracker is tracking an object.",
        "values":[
           {
              "description":"Indicates that a vertical plane is being tracked.",
              "name":"VERTICAL_PLANE"
           },
           {
              "description":"Indicates that the plane tracker is tracking at an arbitrary depth.",
              "name":"ARBITRARY_DEPTH"
           },
           {
              "description":"Indicates that a moving object is being tracked.",
              "name":"MOVING_OBJECT"
           },
           {
              "description":"Indicates that a horizontal plane is being tracked.",
              "name":"PLANE"
           }
        ]
     },
     {
        "name":"ScalingOption",
        "scope":"SceneModule",
        "description":"The `ScalingOption` enum describes how an element is scaled.",
        "values":[
           {
              "description":"Indicates that no scaling is applied to the element.",
              "name":"IGNORE"
           },
           {
              "description":"Indicates that the resource is stretched in the height and width dimensions to fill the container.",
              "name":"STRETCH"
           },
           {
              "description":"Indicates that the resource is scaled proportionately to match the height of the container.",
              "name":"FIT_HEIGHT"
           },
           {
              "description":"Indicates that the resource is scaled proportionately to match the width of the container.",
              "name":"FIT_WIDTH"
           },
           {
              "description":"Indicates that the resource is is tiled to fill the container.",
              "name":"FILL"
           },
           {
              "description":"Indicates that the resource is scaled proportionately such that the larger dimension, height or width, matches the size of the container.",
              "name":"FIT"
           }
        ]
     },
     {
        "name":"VerticalAlignment",
        "scope":"SceneModule",
        "description":"The `VerticalAlignment` enum describes how an element is aligned vertically.",
        "values":[
           {
              "description":"Indicates that the element is aligned at the bottom of the container.",
              "name":"BOTTOM"
           },
           {
              "description":"Indicates that the element is aligned with the center of the container.",
              "name":"CENTER"
           },
           {
              "description":"Indicates that the element is aligned at the top of the container.",
              "name":"TOP"
           }
        ]
     },
     {
        "name":"RenderMode",
        "scope":"SceneModule",
        "description":"The RenderMode enum describes how to render a scene object.",
        "values":[
           {
              "description":"Indicates that the element should be rendered into the 2D screen space.",
              "name":"SCREEN_SPACE"
           },
           {
              "description":"Indicates that the element should be rendered into the 3D world space.",
              "name":"WORLD_SPACE"
           }
        ]
     },
     {
        "name":"CameraPosition",
        "scope":"CameraInfoModule",
        "description":"The `CameraPosition` enum describes the direction the camera is facing.",
        "values":[
           {
              "description":"Indicates that the orientation of the camera is unknown.",
              "name":"BACK"
           },
           {
              "description":"Indicates that the front-facing camera is in use.",
              "name":"FRONT"
           },
           {
              "description":"Indicates that the back-facing camera is in use.",
              "name":"UNSPECIFIED"
           }
        ]
     },
     {
        "name":"SdfVariant",
        "scope":"ShadersModule",
        "description":"The `SdfVariant` enum describes the SDF variant.",
        "values":[
           {
              "description":"sharp SDF variant.",
              "name":"SHARP"
           },
           {
              "description":"Exact SDF variant.",
              "name":"EXACT"
           }
        ]
     },
     {
        "name":"BlendMode",
        "scope":"ShadersModule",
        "description":"The `BlendMode` enum describes the blending mode.",
        "values":[
           {
              "description":"Blends two colors using the Overlay blend mode.",
              "name":"OVERLAY"
           },
           {
              "description":"Blends two colors using the Max blend mode.",
              "name":"MAX"
           },
           {
              "description":"Blends two colors using the Min blend mode.",
              "name":"MIN"
           },
           {
              "description":"Blends two colors using the Burn blend mode.",
              "name":"BURN"
           },
           {
              "description":"Blends two colors using the Dodge blend mode.",
              "name":"DODGE"
           },
           {
              "description":"Blends two colors using the Divide blend mode.",
              "name":"DIVIDE"
           },
           {
              "description":"Blends two colors using the PlusDarker blend mode.",
              "name":"PLUSDARKER"
           },
           {
              "description":"Blends two colors using the Screen blend mode.",
              "name":"SCREEN"
           },
           {
              "description":"Blends two colors using the Multiply blend mode.",
              "name":"MULTIPLY"
           },
           {
              "description":"Blends two colors using the Difference blend mode.",
              "name":"DIFFERENCE"
           },
           {
              "description":"Blends two colors using the Subtract blend mode.",
              "name":"SUBTRACT"
           },
           {
              "description":"Blends two colors using the Add blend mode.",
              "name":"ADD"
           },
           {
              "description":"Blends two colors using the Normal blend mode.",
              "name":"NORMAL"
           }
        ]
     },
     {
        "name":"ColorSpace",
        "scope":"ShadersModule",
        "description":"The `ColorSpace` enum describes the color space.",
        "values":[
           {
              "description":"HSL color space.",
              "name":"HSL"
           },
           {
              "description":"HSV color space.",
              "name":"HSV"
           },
           {
              "description":"RGB color space.",
              "name":"RGB"
           }
        ]
     },
     {
        "name":"DerivativeType",
        "scope":"ShadersModule",
        "description":"The `DerivativeType` enum describes the shader derivative type.",
        "values":[
           {
              "description":"Sum of the absolute derivatives in x and y.",
              "name":"FWIDTH"
           },
           {
              "description":"Derivative in y direction.",
              "name":"DFDY"
           },
           {
              "description":"Derivative in x direction.",
              "name":"DFDX"
           }
        ]
     },
     {
        "name":"State",
        "scope":"TexturesModule.ExternalTexture",
        "description":"The `State` enum describes the download state of an ExternalTexture.",
        "values":[
           {
              "description":"Indicates that the resource has been downloaded.",
              "name":"AVAILABLE"
           },
           {
              "description":"Indicates that the resource failed to download.",
              "name":"FAILED"
           },
           {
              "description":"Indicates that the resource download is pending.",
              "name":"PENDING"
           }
        ]
     },
     {
        "name":"VertexAttribute",
        "scope":"ShadersModule",
        "description":"The `VertexAttribute` enum describes the bultin vertex attributes.",
        "values":[
           {
              "description":"Color vertex attribute.",
              "name":"COLOR"
           },
           {
              "description":"Texture Coordinates vertex attribute.",
              "name":"TEX_COORDS"
           },
           {
              "description":"Tangent vertex attribute.",
              "name":"TANGENT"
           },
           {
              "description":"Normal vertex attribute.",
              "name":"NORMAL"
           },
           {
              "description":"Position vertex attribute.",
              "name":"POSITION"
           }
        ]
     },
     {
        "name":"BuiltinUniform",
        "scope":"ShadersModule",
        "description":"The `BuiltinUniform` enum describes the bultin shader uniforms.",
        "values":[
           {
              "description":"Inverse Projection Matrix uniform.",
              "name":"INV_P_MATRIX"
           },
           {
              "description":"Inverse View Matrix uniform.",
              "name":"INV_V_MATRIX"
           },
           {
              "description":"Inverse Model Matrix uniform.",
              "name":"INV_M_MATRIX"
           },
           {
              "description":"Normal Matrix uniform.",
              "name":"NORMAL_MATRIX"
           },
           {
              "description":"View Projection Matrix uniform.",
              "name":"VP_MATRIX"
           },
           {
              "description":"Projection Matrix uniform.",
              "name":"P_MATRIX"
           },
           {
              "description":"View Matrix uniform.",
              "name":"V_MATRIX"
           },
           {
              "description":"Model View Matrix uniform.",
              "name":"MV_MATRIX"
           },
           {
              "description":"Model Matrix uniform.",
              "name":"M_MATRIX"
           },
           {
              "description":"Model View Projection Matrix uniform.",
              "name":"MVP_MATRIX"
           }
        ]
     },
     {
        "name":"GradientType",
        "scope":"ShadersModule",
        "description":"The `GradientType` enum describes the type of the shader gradient.",
        "values":[
           {
              "description":"The gradient will radiate outward in a circular direction.",
              "name":"CIRCULAR"
           },
           {
              "description":"The gradient will be in vertical direction.",
              "name":"VERTICAL"
           },
           {
              "description":"The gradient will be in horizontal direction.",
              "name":"HORIZONTAL"
           }
        ]
     },
     {
        "name":"WorldUnit",
        "scope":"UnitsModule",
        "description":"The `WorldUnit` enum describes the unit of measurement used in world-space.",
        "values":[
           {
              "description":"Indicates that the world-space is described in yards.",
              "name":"LEGACY"
           },
           {
              "description":"Indicates that the world-space is described in millimeters.",
              "name":"INCH"
           },
           {
              "description":"Indicates that the world-space is described in meters.",
              "name":"FOOT"
           },
           {
              "description":"Indicates that the world-space is described in legacy units.",
              "name":"YARD"
           },
           {
              "description":"Indicates that the world-space is described in inches.",
              "name":"MILLIMETER"
           },
           {
              "description":"Indicates that the world-space is described in feet.",
              "name":"CENTIMETER"
           },
           {
              "description":"Indicates that the world-space is described in centimeters.",
              "name":"METER"
           }
        ]
     }
  ],
  "classes":[
     {
        "name":"TargetTracker",
        "scope":"SceneModule",
        "description":"The `TargetTracker` encapsulates a tracker for some target.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"isTracking",
              "description":"```\n(get) isTracking: BoolSignal\n(set) (Not Available)\n```\n\nSpecifies whether the TargetTracker is actively tracking."
           }
        ]
     },
     {
        "name":"TextAlignmentWrapper",
        "scope":"SceneModule",
        "description":"The `TextAlignmentWrapper` class contains text alignment details.",
        "methods":[

        ],
        "properties":[
           {
              "name":"horizontal",
              "description":"```\n(get) (Not Available)\n(set) horizontal: TextAlignment\n```\n\nSpecifies the horizontal text alignment."
           },
           {
              "name":"vertical",
              "description":"```\n(get) (Not Available)\n(set) vertical: VerticalTextAlignment\n```\n\nSpecifies the vertical text alignment."
           }
        ]
     },
     {
        "name":"PointTracker",
        "scope":"SceneModule",
        "description":"The 'PointerTracker' class describes a point tracker object.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"PointCloud",
        "scope":"SceneModule",
        "description":"The 'PointCloud' class describes a point cloud generated by the World Tracking algorithm",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"HandTrackerSceneObject",
        "scope":"SceneModule",
        "description":"The `HandTrackerSceneObject` class encapsulates a hand tracking object.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"SpotLightSource",
        "scope":"SceneModule",
        "description":"The `SpotLightSource` class describes a spot light source.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"angleOuter",
              "description":"```\n(get) angleInner: ScalarSignal\n(set) angleInner: ScalarSignal\n```\n\nSpecifies the outer angle of the spotlight cone, everything outside is not illuminated. In radians."
           },
           {
              "name":"angleInner",
              "description":"```\n(get) angleInner: ScalarSignal\n(set) angleInner: ScalarSignal\n```\n\nSpecifies the inner angle of the spotlight cone, everything inside is fully illuminated. In radians."
           },
           {
              "name":"intensity",
              "description":"```\n(get) intensity: ScalarSignal\n(set) intensity: ScalarSignal\n```\n\nSpecifies the intensity of this light source, usually between 0.0 and 1.0."
           },
           {
              "name":"color",
              "description":"```\n(get) (Not Available)\n(set) color: ColorSignal\n```\n\nSpecifies the color of this light source."
           }
        ]
     },
     {
        "name":"ScreenPlane",
        "scope":"SceneModule",
        "description":"The `ScreenPlane` class describes a screen plane.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"PlaneTracker",
        "scope":"SceneModule",
        "description":"The `PlaneTracker` class provides functionality for locating a 3D plane based on 2D screen coordinates.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"trackingMode",
              "description":"```\n (get) trackingMode: SceneModule.TrackingMode\n (set) trackingMode: SceneModule.TrackingMode\n ```\n\n Specifies if this tracker object should track horizontal plane or moving object."
           },
           {
              "name":"confidence",
              "description":"```\n(get) confidence: StringSignal\n(set) (Not Available)\n```\n\nReturns tracking confidence level info.\nThis value indicates if PlaneTracker is currently tracking and how confident it is in reported results.\nPossible values:\n- HIGH\n- MEDIUM\n- LOW\n- NOT_TRACKING"
           }
        ]
     },
     {
        "name":"ParticleSystem",
        "scope":"SceneModule",
        "description":"The `ParticleSystem` class implements the particle management system for the scene.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"gravity",
              "description":"```\n(get) (Not Available)\n(set) gravity: VectorSignal\n```\n\nSpecifies the gravity vector for particles of this emitter."
           },
           {
              "name":"position",
              "description":"```\n(get) (Not Available)\n(set) position: PointSignal\n```\n\nSpecifies the mean spawn position of each particle."
           },
           {
              "name":"worldSpace",
              "description":"```\n(get) worldSpace: BoolSignal\n(set) worldSpace: BoolSignal\n```\n\nSpecifies whether the particles will move with the emitter or will have their own position after being emitted."
           },
           {
              "name":"positionDelta",
              "description":"```\n(get) (Not Available)\n(set) positionDelta: VectorSignal\n```\n\nSpecifies the absolute delta value for the `position` property. The position is randomized uniformly in the axis-aligned bounding box with corners `position - d` and `position + d` for each particle.\n\n**Note**: all the coordinates must be non-negative. For negative values, the absolute value is used."
           },
           {
              "name":"initialRotationDelta",
              "description":"```\n(get) initialRotationDelta: ScalarVScalarSignalalue\n(set) initialRotationDelta: ScalarSignal\n```\n\nSpecifies the absolute delta value for the `initialRotation` property. The initial rotation is randomized uniformly in the range `[initialRotation - initialRotationDelta; initialRotation + initialRotationDelta]` for each particle."
           },
           {
              "name":"hsvaColorModulationModifier",
              "description":"```\n(get) (Not Available)\n(set) hsvaColorModulationModifier: ColorSampler\n```\n\nSpecifies the modifier that will be added to the particle color according to the supplied sampler relative to the current relative lifetime of the particle. In other words, if the lifetime is 4 seconds and the particle has lived for is 3 seconds, the modifier will be sampled at 3/4 = 0.75.\n\n**Note**: the modifier works in the HSVA color space, i.e. using values interpolated in RGBA won't add the corresponding R, G or B values to the current color but rather the converted HSV color will be added."
           },
           {
              "name":"positionModifier",
              "description":"```\n(get) (Not Available)\n(set) positionModifier: ArrayOfScalarSamplers\n```\n\nSpecifies the modifier that will be added to the particle position according to the supplied sampler relative to the current relative lifetime of the particle. In other words, if the lifetime is 4 seconds and the particle has lived for is 3 seconds, the modifier will be sampled at 3/4 = 0.75.\n\n**Note**: the specified array of samplers must contain exactly 3 elements, interpreted as X,Y,Z values."
           },
           {
              "name":"types",
              "description":"```\n(get) types: ParticleTypeDescriptions\n(set) (Not Available)\n```\n\nRetrieves the ParticleTypeDescriptions"
           },
           {
              "name":"rotationalVelocityDelta",
              "description":"```\n(get) rotationalVelocityDelta: ScalarSignal\n(set) rotationalVelocityDelta: ScalarSignal\n```\n\nSpecifies the absolute delta value for the `rotationalVelocity` property. The rotation velocity is randomized uniformly in the range `[rotationalVelocity - rotationalVelocityDelta; rotationalVelocity + rotationalVelocityDelta]` for each particle."
           },
           {
              "name":"rotationalDamping",
              "description":"```\n(get) rotationalDamping: ScalarSignal\n(set) rotationalDamping: ScalarSignal\n```\n\nSpecifies the mean rotational damping of each particle."
           },
           {
              "name":"colorModulationHSVA",
              "description":"```\n(get) (Not Available)\n(set) colorModulationHSVA: HsvaSignal\n```\n\nSpecifies the mean color for modulating the particle material.\n\n**Note**: `colorModulationHSVA` can only be an instance of `HsvaSignal`, it cannot be specified in other color space like RGBA.\n\n**Note**: the modulation itself happens in RGBA space. Each of the RGBA components specified by the modulation is multiplied to the corresponding component specified by the particle material."
           },
           {
              "name":"lifetimeSeconds",
              "description":"```\n(get) lifetimeSeconds: ScalarSignal\n(set) lifetimeSeconds: ScalarSignal\n```\n\nSpecifies the mean lifetime of each particle, in seconds."
           },
           {
              "name":"rotationalVelocity",
              "description":"```\n(get) rotationalVelocity: ScalarSignal\n(set) rotationalVelocity: ScalarSignal\n```\n\nSpecifies the mean rotational velocity of each particle, in radians-per-second."
           },
           {
              "name":"outerRadius",
              "description":"```\n(get) outerRadius: ScalarValue\n(set) outerRadius: ScalarSignal\n```\n\nSpecifies the radius of the outer circle when using the ring emitter for the particle system. The particles spawn between `innerRadius` and `outerRadius`.\n\n**Note**: `outerRadius` must be greater-than or equal to `innerRadius`."
           },
           {
              "name":"velocityModifier",
              "description":"```\n(get) (Not Available)\n(set) velocityModifier: ArrayOfScalarSamplers\n```\n\nSpecifies the modifier that will be added to the particle velocity according to the supplied sampler relative to the current relative lifetime of the particle. In other words, if the lifetime is 4 seconds and the particle has lived for is 3 seconds, the modifier will be sampled at 3/4 = 0.75.\n\n**Note**: the specified array of samplers must contain exactly 3 elements, interpreted as X,Y,Z values."
           },
           {
              "name":"initialRotation",
              "description":"```\n(get) initialRotation: ScalarSignal\n(set) initialRotation: ScalarSignal\n```\n\nSpecifies the mean rotation of each particle, in radians."
           },
           {
              "name":"birthrate",
              "description":"```\n(get) birthrate: ScalarSignal\n(set) birthrate: ScalarSignal\n```\n\nSpecifies the particle birthrate, in number of particles per second."
           },
           {
              "name":"initialVelocityMagnitude",
              "description":"```\n(get) initialVelocityMagnitude: ScalarSignal\n(set) initialVelocityMagnitude: ScalarSignal\n```\n\nSpecifies the mean initial velocity magnitude of each particle."
           },
           {
              "name":"material",
              "description":"```\n(get) material: MaterialBase\n(set) material: MaterialBase\n```\n\nSpecifies the material of the scene object."
           },
           {
              "name":"rotationalDampingPercentageDelta",
              "description":"```\n(get) rotationalDampingPercentageDelta: ScalarSignal\n(set) rotationalDampingPercentageDelta: ScalarSignal\n```\n\nSpecifies the percentage delta value, between 0.0 and 1.0, for the `rotationalDamping` property. The rotational dumping is randomized uniformly in the range `[rotationalDamping * (1 - d); rotationalDamping * (1 + d)]` for each particle.\n\n**Note**: The behavior is undefined for values outside the valid range."
           },
           {
              "name":"lifetimeSecondsPercentageDelta",
              "description":"```\n(get) lifetimeSecondsPercentageDelta: ScalarValue\n(set) lifetimeSecondsPercentageDelta: ScalarSignal\n```\n\nSpecifies the percentage delta value, between 0.0 and 1.0, for the `lifetimeSeconds` property. The lifetime is randomized uniformly in the range `[lifetimeSeconds * (1 - d); lifetimeSeconds * (1 + d)]` for each particle.\n\n**Note**: The behavior is undefined for values outside the valid range."
           },
           {
              "name":"initialVelocityAngle",
              "description":"```\n(get) initialVelocityAngle: ScalarSignal\n(set) initialVelocityAngle: ScalarSignal\n```\n\nSpecifies the mean initial velocity angle of each particle, in radians."
           },
           {
              "name":"scale",
              "description":"```\n(get) scale: ScalarSignal\n(set) scale: ScalarSignal\n```\n\nSpecifies the mean size of each particle, in 3d units."
           },
           {
              "name":"sizeModifier",
              "description":"```\n(get) (Not Available)\n(set) sizeModifier: ScalarSampler\n```\n\nSpecifies the modifier that will be added to the particle size according to the supplied sampler relative to the current relative lifetime of the particle. In other words, if the lifetime is 4 seconds and the particle has lived for is 3 seconds, the modifier will be sampled at 3/4 = 0.75."
           },
           {
              "name":"colorModulationHSVADelta",
              "description":"```\n(get) (Not Available)\n(set) colorModulationHSVADelta: HsvaSignal\n```\n\nSpecifies the absolute delta value for the `colorModulationHSVA` property. The modulation color will be randomized uniformly in the axis-aligned bounding box in the HSVA space with corners `colorModulationHSVA - d` and `colorModulationHSVA + d` for each particle.\n\n**Note**: `colorModulationHSVA` can only be an instance of `HsvaSignal`, it cannot be specified in other color space like RGBA.\n\n**Note**: if the hue component of the randomized modulation color is outside of the [0, 1] interval, it is taken modulo 1.0. If any of the saturation, value or alpha components is outside of the [0, 1] interval, its value is clamped.\n\n**Note**: the modulation itself happens in RGBA space. Each of the RGBA components specified by the modulation is multiplied to the corresponding component specified by the particle material."
           },
           {
              "name":"initialVelocityAngleDelta",
              "description":"```\n(get) initialVelocityAngleDelta: ScalarSignal\n(set) initialVelocityAngleDelta: ScalarSignal\n```\n\nSpecifies the absolute delta value for the `initialVelocityAngle` property. The initial velocity angle is randomized uniformly in the range `[initialVelocityAngle - initialVelocityAngleDelta; initialVelocityAngle + initialVelocityAngleDelta]` for each particle."
           },
           {
              "name":"linearDampingPercentageDelta",
              "description":"```\n(get) linearDampingPercentageDelta: ScalarSignal\n(set) linearDampingPercentageDelta: ScalarSignal\n```\n\nSpecifies the percentage delta value, between 0.0 and 1.0, for the `linearDamping` property. The linear dumping is randomized uniformly in the range `[linearDamping * (1 - d); linearDamping * (1 + d)]` for each particle.\n\n**Note**: The behavior is undefined for values outside the valid range."
           },
           {
              "name":"scaleDelta",
              "description":"```\n(get) scaleDelta: ScalarSignal\n(set) scaleDelta: ScalarSignal\n```\n\nSpecifies the percentage delta value, between 0.0 and 1.0, for the `scale` property. The scale is randomized uniformly in the range `[scale * (1 - d); scale * (1 + d)]` for each particle.\n\n**Note**: The behavior is undefined for values outside the valid range."
           },
           {
              "name":"innerRadius",
              "description":"```\n(get) innerRadius: ScalarValue\n(set) innerRadius: ScalarSignal\n```\n\nSpecifies the radius of the inner circle when using the ring emitter for the particle system. The particles spawn between `innerRadius` and `outerRadius`.\n\n**Note**: `outerRadius` must be greater-than or equal to `innerRadius`."
           },
           {
              "name":"birthrateDelta",
              "description":"```\n(get) birthrateDelta: ScalarSignal\n(set) birthrateDelta: ScalarSignal\n```\n\nSpecifies the percentage delta value, between 0.0 and 1.0, for the `birthrate` property. Whenever a particle is spawned, an \"instantaneous birthrate\" is chosen uniformly in the range `[birthrate * (1 - d); birthrate * (1 + d)]` and the next particle will be spawned in (1/instantaneous birthrate) seconds.\n\n**Note**: The behavior is undefined for values outside the valid range."
           },
           {
              "name":"linearDamping",
              "description":"```\n(get) linearDamping: ScalarSignal\n(set) linearDamping: ScalarSignal\n```\n\nSpecifies the mean linear damping of each particle."
           },
           {
              "name":"initialVelocityMagnitudePercentageDelta",
              "description":"```\n(get) initialVelocityMagnitudePercentageDelta: ScalarSignal\n(set) initialVelocityMagnitudePercentageDelta: ScalarSignal\n```\n\nSpecifies the percentage delta value, between 0.0 and 1.0, for the `initialVelocityMagnitude` property. The initial velocity magnitude is randomized uniformly in the range `[initialVelocityMagnitude * (1 - d); initialVelocityMagnitude * (1 + d)]` for each particle.\n\n**Note**: The behavior is undefined for values outside the valid range."
           },
           {
              "name":"opticalFlowSensitivity",
              "description":"```\n(get) opticalFlowSensitivity: ScalarSignal\n(set) opticalFlowSensitivity: ScalarSignal\n```\n\nSpecifies the optical flow sensitivity."
           }
        ]
     },
     {
        "name":"BlendShapesMesh",
        "scope":"SceneModule",
        "description":"The `BlendShapesMesh` class encapsulates multiple blendable meshes.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"Joint",
        "scope":"SceneModule",
        "description":"The `Joint` class encapsulates a joint scene object.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"Plane",
        "scope":"SceneModule",
        "description":"The `Plane` class describes a plane.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"height",
              "description":"```\n(get) height: ScalarSignal\n(set) height: ScalarSignal\n```\n\nSpecifies the vertical size, in 3D units."
           },
           {
              "name":"width",
              "description":"```\n(get) width: ScalarSignal\n(set) width: ScalarSignal\n```\n\nSpecifies the horizontal size, in 3D units."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) y: ScalarSignal\n```\n\nSpecifies the vertical offset, in 3D units."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) x: ScalarSignal\n```\n\nSpecifies the horizontal offset, in 3D units."
           },
           {
              "name":"material",
              "description":"```\n(get) material: MaterialBase\n(set) material: MaterialBase\n```\n\nSpecifies the material of the scene object."
           }
        ]
     },
     {
        "name":"PlanarImage",
        "scope":"SceneModule",
        "description":"The `PlanarImage` class describes an image rendered on a plane.",
        "super":"PlanarObject",
        "methods":[

        ],
        "properties":[
           {
              "name":"material",
              "description":"```\n(get) material: MaterialBase\n(set) material: MaterialBase\n```\n\nSpecifies the material of the scene object."
           }
        ]
     },
     {
        "name":"Skeleton",
        "scope":"SceneModule",
        "description":"The `Skeleton` class describes a skeleton object.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"FaceMesh",
        "scope":"SceneModule",
        "description":"The `FaceMesh` class describes a face mesh.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"material",
              "description":"```\n(get) material: MaterialBase\n(set) material: MaterialBase\n```\n\nSpecifies the material of the scene object."
           }
        ]
     },
     {
        "name":"PlanarText",
        "scope":"SceneModule",
        "description":"The `PlanarText` class describes text on a plane.",
        "super":"PlanarObject",
        "methods":[

        ],
        "properties":[
           {
              "name":"alignment",
              "description":"```\n(get) alignment: TextAlignmentWrapper\n(set) (Not Available)\n```\n\nRepresents the `TextAlignmentWrapper` that contains parameters that specify the text alignment."
           },
           {
              "name":"tracking",
              "description":"```\n(get) (Not Available)\n(set) tracking: number\n```\n\nSpecifies the text spacing. This is the additional distance between letters. Default is zero. Can be negative."
           },
           {
              "name":"maxLines",
              "description":"```\n(get) (Not Available)\n(set) maxLines: ?number\n```\n\nSpecifies the maximum number of lines for the text. If unspecified, the number of lines is unrestricted."
           },
           {
              "name":"scaleToFit",
              "description":"```\n(get) (Not Available)\n(set) scaleToFit: boolean\n```\n\nSpecifies if the text is scaled to fit the container."
           },
           {
              "name":"leading",
              "description":"```\n(get) (Not Available)\n(set) leading: ?number\n```\n\nSpecifies the line spacing. This is the distance between the baselines in the text. If unspecified, spacing defaults to the font size."
           },
           {
              "name":"font",
              "description":"```\n(get) (Not Available)\n(set) font: Font\n```\n\nSets the given font from the fonts registry.\ni.e: myText.font = require('Fonts').get(\"myFontName\")"
           },
           {
              "name":"fontSize",
              "description":"```\n(get) (Not Available)\n(set) fontSize: number\n```\n\nSpecifies the font size of the text."
           },
           {
              "name":"text",
              "description":"```\n(get) text: StringSignal\n(set) text: StringSignal\n```\n\nSpecifies the text displayed."
           },
           {
              "name":"material",
              "description":"```\n(get) (Not Available)\n(set) material: MaterialBase\n```\n\nSpecifies the material of the scene object."
           }
        ]
     },
     {
        "name":"PlanarFlexItem",
        "scope":"SceneModule",
        "description":"The `PlanarFlexItem` class describes a flex item on a plane.",
        "super":"PlanarObject",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"PlanarFlexContainer",
        "scope":"SceneModule",
        "description":"The `PlanarFlexContainer` class describes a flex container on a plane.",
        "super":"PlanarObject",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"FocalDistance",
        "scope":"SceneModule",
        "description":"The `FocalDistance` class describes a focal distance.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"Camera",
        "scope":"SceneModule",
        "description":"The `Camera` class exposes details about the device camera focal area.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"focalPlane",
              "description":"```\n(get) focalPlane: FocalPlane\n(set) (Not Available)\n```\n\nReturns focal plane info.\nFocal Plane is a virtual plane placed in 3D space in front of camera, it will exactly match output size when rendered.\nThis can be used to convert points between screen and world space."
           }
        ]
     },
     {
        "name":"DefaultMaterial",
        "scope":"MaterialsModule",
        "description":"The `DefaultMaterial` class encapsulates an image-based material.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"emissive",
              "description":"```\n  (get) emissive: TextureBase\n  (set) emissive: TextureBase\n  ```\n\n  Specifies the emissive texture of the material."
           },
           {
              "name":"emissiveTextureTransform",
              "description":"```\n  (get) transform: TextureTransform\n  (set) transform: TextureTransformSignal\n  ```\n\n  Specifies the coordinates transform of the emissive texture of this material."
           },
           {
              "name":"multiplyTextureTransform",
              "description":"```\n(get) transform: TextureTransform\n(set) transform: TextureTransformSignal\n```\n\nSpecifies the coordinates transform of the multiplicative texture of this material."
           },
           {
              "name":"reflective",
              "description":"```\n(get) reflective: TextureBase\n(set) reflective: TextureBase\n```\n\nSpecifies the reflective texture of the material."
           },
           {
              "name":"multiply",
              "description":"```\n(get) multiply: TextureBase\n(set) multiply: TextureBase\n```\n\nSpecifies the multiplicative texture of the material. This can be used for masking and other purposes."
           },
           {
              "name":"__internalEmissiveTextureIdentifier",
              "description":"```\n(get) __internalEmissiveTextureIdentifier: String\n(set) (Not Available)\n```\nSpecifies the unique emissive identifier for the texture, assigned to material."
           },
           {
              "name":"__internalMultiplyTextureIdentifier",
              "description":"```\n(get) __internalMultiplyTextureIdentifier: String\n(set) (Not Available)\n```\nSpecifies the unique multiply identifier for the texture, assigned to material."
           },
           {
              "name":"__internalEnvironmentTextureIdentifier",
              "description":"```\n(get) __internalEnvironmentTextureIdentifier: String\n(set) (Not Available)\n```\nSpecifies the unique environment identifier for the texture, assigned to material."
           }
        ]
     },
     {
        "name":"DirectionalLightSource",
        "scope":"SceneModule",
        "description":"The `DirectionalLightSource` class describes a directional light source.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"intensity",
              "description":"```\n(get) intensity: ScalarSignal\n(set) intensity: ScalarSignal\n```\n\nSpecifies the intensity of this light source, usually between 0.0 and 1.0."
           },
           {
              "name":"color",
              "description":"```\n(get) (Not Available)\n(set) color: ColorSignal\n```\n\nSpecifies the color of this light source."
           }
        ]
     },
     {
        "name":"AmbientLightSource",
        "scope":"SceneModule",
        "description":"The `AmbientLightSource` class describes an ambient lighting source.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"intensity",
              "description":"```\n(get) intensity: ScalarSignal\n(set) intensity: ScalarSignal\n```\n\nSpecifies the intensity of this light source, usually between 0.0 and 1.0."
           },
           {
              "name":"color",
              "description":"```\n(get) (Not Available)\n(set) color: ColorSignal\n```\n\nSpecifies the color of this light source."
           }
        ]
     },
     {
        "name":"TimeModule",
        "description":"The `TimeModule` class enables time-based events.",
        "exampleCode":"const Time = require('Time');\nconst Diagnostics = require('Diagnostics');\n\n// One-shot timers:\nTime.setTimeout(\n  function (elapsedTime) {\n    Diagnostics.log('You should see this message in the console.');\n  }, 1300);\n\nvar cancelableTimer = Time.setTimeout(\n  function (elapsedTime) {\n    Diagnostics.log('You should not see this message in the console.');\n  }, 2900);\n\n// Repeating timer:\nTime.ms.interval(1700).subscribe(\n  function (elapsedTime) {\n    // NOTE: Time.ms may differ slightly from the elapsed\n    // time passed to the callback. Time.ms shows the exact\n    // time since the effect started, whereas the callback\n    // exposes an exact multiple of the specified interval.\n    Diagnostics.log(Time.ms.lastValue);\n    Diagnostics.log(elapsedTime);\n    Time.clearTimeout(cancelableTimer);\n  });",
        "super":"Module",
        "methods":[
           {
              "name":"clearInterval",
              "description":"```\nclearInterval(timer: Subscription): void\n```\n\nCancels a callback set by `setInterval`. This function is provided as a to match the traditional JS `clearInterval` API.\n\n**Note**: This is equivalent to `Subscription.unsubscribe`."
           },
           {
              "name":"setInterval",
              "description":"```\nsetInterval(callback: Function, delay: Number): Subscription\n```\n\nReturns a `Subscription` object. The function specified by `callback` is called at intervals specified by `delay` in milliseconds. The `setInterval` will continue calling the `callback` until `TimeModule.clearInterval` is called. The `callback` is a function that has one argument, the elapsed time since the timer started. An exception is thrown when the `delay` is zero or less.\n\n**Note**: An interval can be canceled either via `Subscription.unsubscribe` or `TimeModule.clearInterval`."
           },
           {
              "name":"clearTimeout",
              "description":"```\nclearTimeout(timer: Subscription): void\n```\n\nCancels a callback set by `setTimeout`. This has no effect if the timeout has already been triggered. This function is provided as a to match the traditional JS `clearTimeout` API.\n\n**Note**: This is equivalent to `Subscription.unsubscribe`."
           },
           {
              "name":"setTimeoutWithSnapshot",
              "description":"```\nsetTimeout(snapshot: { [string]: Signal}, callback: Function, delay: Number): Subscription\n```\n\nReturns a `Subscription` object. The function specified by `callback` is called after the specified `delay` in milliseconds using `Snapshot` of signals.\n`Snapshot` is a dictionary of String/Bool/Scalar signals, which will be passed as JSON to the callback function using lastValue from requested signals.\n\nThe `callback` is a function that has two arguments, the elapsed time since the timer started and the snapshot JSON.\n\n**Note**: A timeout can be canceled either via `Subscription.unsubscribe` or `TimeModule.clearTimeout`.\n\n**Note**: This is equivalent to `Time.ms.sub(Time.ms.pin()).trigger(delay).subscribeWithSnapshot(snapshot, callback)`."
           },
           {
              "name":"setIntervalWithSnapshot",
              "description":"```\nsetInterval(snapshot: { [string]: Signal}, callback: Function, delay: Number): Subscription\n```\nReturns a `Subscription` object.\nThe function specified by `callback` is called at intervals specified by `delay` in milliseconds using `Snapshot` of signals.\n`Snapshot` is a dictionary of String/Bool/Scalar signals, which will be passed as JSON to the callback function using lastValue from requested signals.\n\nThe `setIntervalWithSnapshot` will continue calling the `callback` until `TimeModule.clearInterval` is called.\nThe `callback` is a function that has two arguments, the elapsed time since the timer started, and the snapshot JSON\nAn exception is thrown when the `delay` is zero or less.\n\n**Note**: An interval can be canceled either via `Subscription.unsubscribe` or `TimeModule.clearInterval`."
           },
           {
              "name":"setTimeout",
              "description":"```\nsetTimeout(callback: Function, delay: Number): Subscription\n```\n\nReturns a `Subscription` object. The function specified by `callback` is called after the specified `delay` in milliseconds. The `callback` is a function that has one argument, the elapsed time since the timer started.\n\n**Note**: A timeout can be canceled either via `Subscription.unsubscribe` or `TimeModule.clearTimeout`.\n\n**Note**: This is equivalent to `Time.ms.sub(Time.ms.pin()).trigger(delay).subscribe(callback)`."
           }
        ],
        "properties":[
           {
              "name":"ms",
              "description":"```\n(get) ms: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies a `ScalarSignal` indicating the number of milliseconds elapsed since the first frame."
           }
        ]
     },
     {
        "name":"AnimationModule",
        "description":"The `AnimationModule` class implements object animation.",
        "exampleCode":"const Animation = require('Animation');\nconst Scene = require('Scene');\nconst FaceTracking = require('FaceTracking');\n\nconst plane = Scene.root.find('plane0');\n\n// Animate the Face Mesh's vertical scale according to the mouth openness\nconst mouthOpennessDriver = Animation.valueDriver(FaceTracking.face(0).mouth.openness, 0.1, 0.6);\nconst linearSampler = Animation.samplers.linear(1, 2);\nconst scaleAnimation = Animation.animate(mouthOpennessDriver, linearSampler);\n\nplane.transform.scaleY = scaleAnimation;\n\n// Animate the Face Mesh's horizontal position continuously\nconst timeDriver = Animation.timeDriver({durationMilliseconds: 1500, loopCount: Infinity, mirror: true});\nconst quadraticSampler = Animation.samplers.easeInOutQuad(-0.1, 0.1);\nconst translationAnimation = Animation.animate(timeDriver, quadraticSampler);\n\nplane.transform.x = translationAnimation;\ntimeDriver.start(); // TimeDriver-based animations need to be started explicitly.",
        "super":"Module",
        "methods":[
           {
              "name":"animate",
              "description":"```\nanimate(driver: Driver, sampler: ScalarSampler): ScalarSignal\nanimate(driver: Driver, sampler: ArrayOfScalarSamplers): ArrayOfScalarSignals\nanimate(driver: Driver, sampler: RotationSampler): RotationSignal\nanimate(driver: Driver, sampler: ColorSampler): RgbaSignal\n```\n\nCombines the driver and the sampler to create a signal that can be used to animate arbitrary properties of arbitrary objects.\n\nFor `TimeDriver`-based animations the animation will start only when `TimeDriver.start` is invoked."
           },
           {
              "name":"valueDriver",
              "description":"```\nvalueDriver(value: ScalarSignal, min: number, max: number): ValueDriver\n```\n\nReturns a `ValueDriver` object that drives an animation based on values emitted from a `ScalarValue`. The signal values are normalized and clamped to maximum and minimum values."
           },
           {
              "name":"timeDriver",
              "description":"```\ntimeDriver(timeDriverParams: {durationMilliseconds: number, loopCount: ?number, mirror: ?boolean}): TimeDriver\n```\n\nReturns a `TimeDriver` object that drives an animation for the specified parameters.\n`loopCount` defines the number of iterations before the time driver stops; this can be infinity.\nWhen `mirror` is `TRUE`, the time driver follows a *yoyo* effect with every odd iteration going forwards and every even iteration going backwards."
           }
        ],
        "properties":[
           {
              "name":"samplers",
              "description":"```\n(get) samplers: SamplerFactory\n(set) (Not Available)\n```\n\nSpecifies an instance of a `SamplerFactory` object."
           }
        ]
     },
     {
        "name":"ArrayOfScalarSamplers",
        "scope":"AnimationModule",
        "description":"The `ArrayOfScalarSamplers` class describes an array of scalar samplers.",
        "methods":[
           {
              "name":"get",
              "description":"```\nget(index: number): ScalarSampler\n```\n\nReturns the sampler indicated by the `index` parameter."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"SamplerFactory",
        "scope":"AnimationModule",
        "description":"The `SamplerFactory` class creates different types of animation samplers.",
        "methods":[
           {
              "name":"easeOutBounce",
              "description":"```\neaseOutBounce(beginValue: number, endValue: number): ScalarSampler\neaseOutBounce(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInBounce",
              "description":"```\neaseInBounce(beginValue: number, endValue: number): ScalarSampler\neaseInBounce(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeOutElastic",
              "description":"```\neaseOutElastic(beginValue: number, endValue: number): ScalarSampler\neaseOutElastic(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeOutBack",
              "description":"```\neaseOutBack(beginValue: number, endValue: number): ScalarSampler\neaseOutBack(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutCirc",
              "description":"```\neaseInOutCirc(beginValue: number, endValue: number): ScalarSampler\neaseInOutCirc(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInElastic",
              "description":"```\neaseInElastic(beginValue: number, endValue: number): ScalarSampler\neaseInElastic(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeOutCirc",
              "description":"```\neaseOutCirc(beginValue: number, endValue: number): ScalarSampler\neaseOutCirc(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInCirc",
              "description":"```\neaseInCirc(beginValue: number, endValue: number): ScalarSampler\neaseInCirc(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"RGBA",
              "description":"```\nRGBA(channelSamplers: ArrayOfScalarSamplers): ColorSampler\n```\n\nReturns a sampler that specifies a color by interpreting the provided samplers as RGBA channels, respectively.\n\nThe dimension of `channelSamplers` must be exactly 4.\n`channelSamplers` must be an instance of `ArrayOfScalarSamplers`, not a JavaScript Array object."
           },
           {
              "name":"easeOutQuint",
              "description":"```\neaseOutQuint(beginValue: number, endValue: number): ScalarSampler\neaseOutQuint(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInQuint",
              "description":"```\neaseInQuint(beginValue: number, endValue: number): ScalarSampler\neaseInQuint(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInQuart",
              "description":"```\neaseInQuart(beginValue: number, endValue: number): ScalarSampler\neaseInQuart(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutExpo",
              "description":"```\neaseInOutExpo(beginValue: number, endValue: number): ScalarSampler\neaseInOutExpo(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutCubic",
              "description":"```\neaseInOutCubic(beginValue: number, endValue: number): ScalarSampler\neaseInOutCubic(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutBounce",
              "description":"```\neaseInOutBounce(beginValue: number, endValue: number): ScalarSampler\neaseInOutBounce(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeOutCubic",
              "description":"```\neaseOutCubic(beginValue: number, endValue: number): ScalarSampler\neaseOutCubic(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeOutQuad",
              "description":"```\neaseOutQuad(beginValue: number, endValue: number): ScalarSampler\neaseOutQuad(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"frame",
              "description":"```\nframe(numberOfFrames: number): ScalarSampler\nframe(numberOfFrames: number, startFrame: number): ScalarSampler\nframe(numberOfFrames: number[]): ArrayOfScalarSamplers\nframe(numberOfFrames: number[], startFrame: number[]): ArrayOfScalarSamplers\n```\n\nReturns a sampler object that cyclically generates integer frame numbers in the range [0..`numberOfFrames`-1] as the attached driver's progress goes from 0.0 to 1.0.\n\nIf the `startFrame` is supplied, then the output values are shifted by that value."
           },
           {
              "name":"easeInOutSine",
              "description":"```\neaseInOutSine(beginValue: number, endValue: number): ScalarSampler\neaseInOutSine(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInQuad",
              "description":"```\neaseInQuad(beginValue: number, endValue: number): ScalarSampler\neaseInQuad(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"sequence",
              "description":"```\nsequence(config: { samplers: ScalarSampler[], knots: ?number[] }): ScalarSampler\nsequence(config: { samplers: ArrayOfScalarSamplers[], knots: ?number[] }): ArrayOfScalarSamplers\n```\n\nReturns an animation sequence built from provided segments with respect to the optionally provided knots.\n\n`config.samplers` must contain at least 2 elements.\n`config.knots`, if specified, must contain exactly `config.samplers.length`+1 elements.\nThe first element of `config.knots`, when specified, must always be zero.\nIf `config.knots` is not specified then the knot sequence defaults to [0, 1, 2, ..., `config.samplers.length`]."
           },
           {
              "name":"bezier",
              "description":"```\nbezier(p0: number, p1: number, p2: number, p3: number): ScalarSampler\nbezier(p0: number[], p1: number[], p2: number[], p3: number[]): ArrayOfScalarSamplers\n```\n\nReturns a sampler object that generates values of a cubic Bezier curve with the specified control points. The control points are assumed to be equidistant along the parameter axis."
           },
           {
              "name":"easeOutExpo",
              "description":"```\neaseOutExpo(beginValue: number, endValue: number): ScalarSampler\neaseOutExpo(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutQuad",
              "description":"```\neaseInOutQuad(beginValue: number, endValue: number): ScalarSampler\neaseInOutQuad(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInExpo",
              "description":"```\neaseInExpo(beginValue: number, endValue: number): ScalarSampler\neaseInExpo(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutQuart",
              "description":"```\neaseInOutQuart(beginValue: number, endValue: number): ScalarSampler\neaseInOutQuart(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInSine",
              "description":"```\neaseInSine(beginValue: number, endValue: number): ScalarSampler\neaseInSine(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"polyline",
              "description":"```\npolyline(config: { keyframes: number[], knots: ?number[] }): ScalarSampler\npolyline(config: { keyframes: number[][], knots: ?number[] }): ArrayOfScalarSamplers\npolyline(config: { keyframes: Rotation[], knots: ?number[] }): RotationSampler\n```\n\nReturns a sampler object that generates values that goes piecewise linearly through specified `keyframes` as the attached driver's progress goes from 0.0 to 1.0 through normalized `knots` points.\n\nThe dimensions of the `config.keyframes` and `config.knots` arrays, if specified, must be equal and be not less than 2. The first element of `config.knots`, if specified, must be zero. If `config.knots` is not specified then the knot sequence defaults to [0, 1, 2, ..., `config.keyframes.length` - 1]."
           },
           {
              "name":"easeInCubic",
              "description":"```\neaseInCubic(beginValue: number, endValue: number): ScalarSampler\neaseInCubic(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutElastic",
              "description":"```\neaseInOutElastic(beginValue: number, endValue: number): ScalarSampler\neaseInOutElastic(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInBack",
              "description":"```\neaseInBack(beginValue: number, endValue: number): ScalarSampler\neaseInBack(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeInOutQuint",
              "description":"```\neaseInOutQuint(beginValue: number, endValue: number): ScalarSampler\neaseInOutQuint(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"linear",
              "description":"```\nlinear(beginValue: number, endValue: number): ScalarSampler\nlinear(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nReturns a sampler object that generates values that change linearly from `beginValue` to `endValue` as the attached driver's progress goes from 0.0 to 1.0."
           },
           {
              "name":"easeInOutBack",
              "description":"```\neaseInOutBack(beginValue: number, endValue: number): ScalarSampler\neaseInOutBack(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"easeOutSine",
              "description":"```\neaseOutSine(beginValue: number, endValue: number): ScalarSampler\neaseOutSine(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"polybezier",
              "description":"```\npolybezier(config: { keyframes: number[], knots: ?number[], tangents: ?number[] }): ScalarSampler\npolybezier(config: { keyframes: number[][], knots: ?number[], tangents: ?number[][] }): ArrayOfScalarSamplers\n```\n\nReturns a sampler object that generates values of a piecewise cubic Bezier spline that goes through specified `keyframes` as the attached driver's progress goes from 0.0 to 1.0 through normalized `knots` points.\n\nWhen `tangents` is specified, the curve is C1-smooth, otherwise the curve is C2-smooth and the second derivatives at the begin and end points are zero.\n\nThe dimensions of `config.keyframes` and `config.knots`, if specified, and `config.tangents`, if specified, arrays must be equal and have no less than 2 elements. The first element of `config.knots`, if specified, must always be zero. If `config.knots` is not specified then the knot sequence is defaulted to [0, 1, 2, ..., `config.keyframes.length` - 1]."
           },
           {
              "name":"easeOutQuart",
              "description":"```\neaseOutQuart(beginValue: number, endValue: number): ScalarSampler\neaseOutQuart(beginValue: number[], endValue: number[]): ArrayOfScalarSamplers\n```\n\nEasing sampler. Behaves similarly to the linear sampler, but with easing functions at the beginning and/or end."
           },
           {
              "name":"HSVA",
              "description":"```\nHSVA(channelSamplers: ArrayOfScalarSamplers): ColorSampler\n```\n\nReturns a sampler that specifies a color by interpreting the provided samplers as HSVA channels, respectively.\n\nThe dimension of `channelSamplers` must be exactly 4.\n`channelSamplers` must be an instance of `ArrayOfScalarSamplers`, not a regular JS Array object."
           },
           {
              "name":"constant",
              "description":"```\nconstant(value: number): ScalarSampler\nconstant(value: number[]): ArrayOfScalarSamplers\n```\n\nReturns a sampler that returns the same value at all points in the animation."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"ParticleTypeDescriptions",
        "scope":"SceneModule",
        "description":"The `ParticleTypeDescriptions` class provides a container for particle type descriptions.",
        "methods":[
           {
              "name":"get",
              "description":"```\nget(index: number): ParticleTypeDescription\n```\n\nRetrieves the particle type description at that index. The particle type descriptions specify which frames of the sprite sheet the particle should use. From scripting, the frames that the ParticleTypeDescription is using cannot be changed, but the user can change their percentages, i.e if there are 2 particle types, with percentages 0.5 each, the user can change from scripting to make one particle type more dense than the other by changing their fractions, for example to 0.3 and 0.7 respectively."
           }
        ],
        "properties":[
           {
              "name":"count",
              "description":"```\n (get) count: number\n\n (set) (Not Available)\n ```\n\n Retrieves the number of existing Particle Type Descriptions"
           }
        ]
     },
     {
        "name":"Rotation",
        "scope":"ReactiveModule",
        "description":"The `Rotation` class encapsulates an object's rotation.",
        "exampleCode":"// The following example uses ReactiveModule.rotation(w,x,y,z) to construct a rotation\n// from a quaternion-based representation of it. The constructed rotation is used with\n// AnimationModule.samplers.polyline to create a rotation animation that is expressed as a RotationSignal.\n\nvar SceneModule = require('Scene');\nvar AnimationModule = require('Animation');\nvar ReactiveModule = require('Reactive');\n\n// Construct a Rotation object from a quaternion-based values.\nfunction axisRotation(axis_x, axis_y, axis_z, angle_degrees) {\n    var norm = Math.sqrt(axis_x*axis_x + axis_y*axis_y + axis_z*axis_z);\n    axis_x /= norm;\n    axis_y /= norm;\n    axis_z /= norm;\n    var angle_radians = angle_degrees * Math.PI / 180.0;\n    var cos = Math.cos(angle_radians/2);\n    var sin = Math.sin(angle_radians/2);\n    return ReactiveModule.rotation(\n        cos, axis_x*sin, axis_y*sin, axis_z*sin);\n}\n\nvar time_driver = AnimationModule.timeDriver({\n    durationMilliseconds: 2000,\n    loopCount: Infinity\n});\n\n// Create a rotation sampler using Rotation objects generated\n// by the previously-defined axisRotation() method.\nvar rotation_sampler = AnimationModule.samplers.polyline({\n    keyframes: [\n        axisRotation(1,0,0,0),\n        axisRotation(1,0,0,45),\n        axisRotation(1,1,0,45),\n        axisRotation(1,0,1,45),\n        axisRotation(1,0,0,0)\n    ],\n    knots: [\n        0, 1, 3, 5, 7\n    ]\n});\n\n// Start the animation\nvar rotation_signal = AnimationModule.animate(time_driver, rotation_sampler);\ntime_driver.start();\n\n// Apply the rotation transform to a scene object.\nvar plane = SceneModule.root.find('plane0');\nplane.transform.rotation = rotation_signal;",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ValueDriver",
        "scope":"AnimationModule",
        "description":"The `ValueDriver` class controls an animation value.",
        "super":"Driver",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"PointLightSource",
        "scope":"SceneModule",
        "description":"The `PointLightSource` class describes a point light source.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"intensity",
              "description":"```\n(get) intensity: ScalarSignal\n(set) intensity: ScalarSignal\n```\n\nSpecifies the intensity of this light source, usually between 0.0 and 1.0."
           },
           {
              "name":"color",
              "description":"```\n(get) (Not Available)\n(set) color: ColorSignal\n```\n\nSpecifies the color of this light source."
           }
        ]
     },
     {
        "name":"Driver",
        "scope":"AnimationModule",
        "description":"The `Driver` class encapsulates an animation driver.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"SignalRecorder",
        "scope":"AnimationModule",
        "description":"The `SignalRecorder` class enables recording and playback of signal values",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"PrimitiveOrShaderSignal",
        "scope":"ReactiveModule",
        "description":"The `PrimitiveOrShader` represents a primitive or shader signal.",
        "super":"ISignal",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ColorSampler",
        "scope":"AnimationModule",
        "description":"The `ColorSampler` class encapsulates a color sampler.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ScalarSampler",
        "scope":"AnimationModule",
        "description":"The `ScalarSampler` class encapsulates a scalar value sampler.",
        "exampleCode":"const Animation = require('Animation');\nconst timeDriver = //...\nconst quadraticTransition = Animation.samplers.easeInOutQuad(-0.1, 0.1);\nconst translationAnimation = Animation.animate(timeDriver, quadraticTransition);",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"FaceTracker",
        "scope":"SceneModule",
        "description":"The `FaceTracker` class propagates details of detected faces to the scene.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"Speaker",
        "scope":"SceneModule",
        "description":"The `Speaker` class encapsulates an speaker for a scene. Old class name is `AudioSource`.",
        "super":"SceneObjectBase",
        "methods":[
           {
              "name":"stopAll",
              "description":"```\nstopAll(speaker: Speaker): void\n```\n\nStops all playing instances of this AudioSource."
           },
           {
              "name":"play",
              "description":"```\nplay(): void\n```\n\nCreates a new playing instance of the sound associated with this AudioSource."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"MaterialsModule",
        "description":"The `Materials` module enables working with textures and making adjustments to qualities like opacity and reflectivity.",
        "exampleCode":"const Materials = require('Materials');\nconst Scene = require('Scene');\n\nconst redMaterial = Materials.get('redMaterial');\nconst plane = Scene.root.find('plane');\n\nplane.material = redMaterial;",
        "super":"Module",
        "methods":[
           {
              "name":"get",
              "description":"```\nget(materialName: string): MaterialBase\n```\n\nReturns a `MaterialBase` class that represents the material specified by the `materialName` parameter. The materials are defined in the AR Studio project.\n\nAn exception is thrown when the identifier isn't found in the project.\n\n**See Also**: `MaterialBase.name`."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"RotationSampler",
        "scope":"AnimationModule",
        "description":"The `RotationSampler` class is an animation sampler for object rotation.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"BlendedMaterial",
        "scope":"MaterialsModule",
        "description":"The `BlendedMaterial` class encapsulates materials blended from multiple textures.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"RetouchingMaterial",
        "scope":"MaterialsModule",
        "description":"The `RetouchingMaterial` class encapsulates parameters which define the extend of certain beautification techniques.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"fullScreen",
              "description":"```\n(get) fullScreen: BoolSignal\n(set) fullScreen: BoolSignal\n```\n\nSpecifies whether effect should be full-screen."
           },
           {
              "name":"skinSmoothingFactor",
              "description":"```\n(get) skinSmoothingFactor: ScalarSignal\n(set) skinSmoothingFactor: ScalarSignal\n```\n\nSpecifies the simulated skin smoothness factor."
           },
           {
              "name":"eyeBrighteningFactor",
              "description":"```\n(get) eyeBrighteningFactor: ScalarSignal\n(set) eyeBrighteningFactor: ScalarSignal\n```\n\nSpecifies the simulated eye whitening factor."
           },
           {
              "name":"teethWhiteningFactor",
              "description":"```\n(get) teethWhiteningFactor: ScalarSignal\n(set) teethWhiteningFactor: ScalarSignal\n```\n\nSpecifies the simulated teeth whitening factor."
           }
        ]
     },
     {
        "name":"DeepLinkTexture",
        "scope":"TexturesModule",
        "description":"The `DeepLinkTexture` class represents an image texture passed in via the sharing SDK.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ExternalTexture",
        "scope":"TexturesModule",
        "description":"The `ExternalTexture` class encapsulates a visual asset that is downloaded over the network.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"state",
              "description":"```\n(get) state: StringSignal\n(set) (Not Available)\n```\n\nSpecifies a `StringSignal` representing the loading state of the external texture. The value of the signal is guaranteed to be a member of the `TexturesModule.ExternalTexture.State` enumeration."
           },
           {
              "name":"url",
              "description":"```\n(get) url: StringValue\n(set) url: StringSignal\n```\n\nSpecifies the URL of the texture to be downloaded."
           }
        ]
     },
     {
        "name":"ImageTexture",
        "scope":"TexturesModule",
        "description":"The `ImageTexture` class encapsulates an image that may be used to form materials for rendering in the scene.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"BlendShapeToWarpMapMaterial",
        "scope":"MaterialsModule",
        "description":"The `BlendShapeToWarpMapMaterial` class.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ShadersModule",
        "description":"The `ShadersModule` exposes the JavaScript Shaders API.",
        "super":"Module",
        "methods":[
           {
              "name":"sdfRotationalRepeat",
              "description":"```\nShadersModule.sdfRotationalRepeat(sdf: ShaderSignal, pivot: ShaderSignal, radius: ShaderSignal, numTimes: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape's rotational repetition numTimes at the given radius.\nShape should be centered at pivot and fit within the angular sector defined by numTimes at the given radius."
           },
           {
              "name":"sdfRotation",
              "description":"```\nShadersModule.sdfRotation(sdf: ShaderSignal, pivot: ShaderSignal, angle: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape rotated around the given pivot by the given angle."
           },
           {
              "name":"sdfTranslation",
              "description":"```\nShadersModule.sdfTranslation(sdf: ShaderSignal, offset: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape translated by the given offset."
           },
           {
              "name":"sdfSmoothIntersection",
              "description":"```\nShadersModule.sdfSmoothIntersection(sdf1: ShaderSignal, sdf2: ShaderSignal, K: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the smooth intersection of the two given SDF shapes, modulated by K."
           },
           {
              "name":"sdfSmoothUnion",
              "description":"```\nShadersModule.sdfSmoothUnion(sdf1: ShaderSignal, sdf2: ShaderSignal, K: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the smooth union of the two given SDF shapes, modulated by K."
           },
           {
              "name":"sdfIntersection",
              "description":"```\nShadersModule.sdfIntersection(sdf1: ShaderSignal, sdf2: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the intersection of the two given SDF shapes."
           },
           {
              "name":"fallback",
              "description":"```\nShadersModule.fallback(main: ShaderSignal, fallback: ShaderSignal): ShaderSignal\n```\n\nForwards the main input if present, otherwise uses fallback."
           },
           {
              "name":"sdfComplement",
              "description":"```\nShadersModule.sdfComplement(sdf: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the complement of the given SDF shape."
           },
           {
              "name":"functionScalar",
              "description":"```\nShadersModule.functionScalar(): ShaderSignal\nShadersModule.functionVec2(): ShaderSignal\nShadersModule.functionVec3(): ShaderSignal\nShadersModule.functionVec4(): ShaderSignal\n```\n\nReturns a signal for the identity function over the specified type."
           },
           {
              "name":"textureTransform",
              "description":"```\nShadersModule.textureTransform(texture: ShaderSignal, transform: ShaderSignal): ShaderSignal\n```\n\nTransforms the given texture with the specified Mat3 transform."
           },
           {
              "name":"sdfStar",
              "description":"```\nShadersModule.sdfStar(center: ShaderSignal, radius1: ShaderSignal, radius2: ShaderSignal, numSides: ShaderSignal): ShaderSignal\n```\n\nReturns a signal for polygon SDF shape."
           },
           {
              "name":"sdfRepeat",
              "description":"```\nShadersModule.sdfRepeat(sdf: ShaderSignal, pivot: ShaderSignal, size: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape's grid repetition.\nShape should be centered at pivot and fit within the given size."
           },
           {
              "name":"sdfCircle",
              "description":"```\nShadersModule.sdfCircle(center: ShaderSignal, radius: ShaderSignal): ShaderSignal\n```\n\nReturns a signal for circle SDF shape."
           },
           {
              "name":"colorSpaceConvert",
              "description":"```\nShadersModule.colorSpaceConvert(color: ShaderSignal, {\"inColorSpace\": ShadersModule.ColorSpace.RGB, \"outColorSpace\": ShadersModule.ColorSpace.HSV}): ShaderSignal\n```\n\nConverts a color from the input color space to the output colorspace."
           },
           {
              "name":"functionVec2",
              "description":"```\nShadersModule.functionScalar(): ShaderSignal\nShadersModule.functionVec2(): ShaderSignal\nShadersModule.functionVec3(): ShaderSignal\nShadersModule.functionVec4(): ShaderSignal\n```\n\nReturns a signal for the identity function over the specified type."
           },
           {
              "name":"blend",
              "description":"```\nShadersModule.blend(src: ShaderSignal, dest: ShaderSignal, {\"mode\": ShadersModule.BlendMode.OVERLAY}): ShaderSignal\n```\n\nBlends two colors with the specified blending mode."
           },
           {
              "name":"sdfEllipse",
              "description":"```\nShadersModule.sdfEllipse(center: ShaderSignal, halfSize: ShaderSignal): ShaderSignal\n```\n\nReturns a signal for ellipse SDF shape."
           },
           {
              "name":"textureSampler",
              "description":"```\nShadersModule.textureSampler(texture: ShaderSignal, uv: ShaderSignal): ShaderSignal\n```\n\nSamples the given texture at the specified uv coordinates."
           },
           {
              "name":"vertexTransform",
              "description":"```\nShadersModule.vertexTransform({\"variableName\": ShadersModule.BuiltinUniform.MVP_MATRIX}): ShaderSignal\n```\n\nReturns a signal for the specified vertex transform."
           },
           {
              "name":"derivative",
              "description":"```\nShadersModule.derivative(val: ShaderSignal, {\"derivativeType\": ShadersModule.DerivativeType.FWIDTH}): ShaderSignal\n```\n\nReturns a signal for the specified shader derivative of the given signal."
           },
           {
              "name":"sdfShear",
              "description":"```\nShadersModule.sdfShear(sdf: ShaderSignal, pivot: ShaderSignal, shear: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape scaled around the given pivot by the given shear amount."
           },
           {
              "name":"sdfLine",
              "description":"```\nShadersModule.sdfLine(offset: ShaderSignal, normal: ShaderSignal, halfSize: ShaderSignal): ShaderSignal\n```\n\nReturns a signal for line SDF shape."
           },
           {
              "name":"composition",
              "description":"```\nShadersModule.composition(f: ShaderSignal, g: ShaderSignal): ShaderSignal\n```\n\nReturns a signal for the shader composition of the two given functions (e.g. texture and a transform)."
           },
           {
              "name":"sdfHalfPlane",
              "description":"```\nShadersModule.sdfHalfPlane(offset: ShaderSignal, normal: ShaderSignal): ShaderSignal\n```\n\nReturns a signal for half-plane SDF shape."
           },
           {
              "name":"gradient",
              "description":"```\nShadersModule.gradient({\"variableName\": ShadersModule.GradientType.HORIZONTAL}): ShaderSignal\n```\n\nReturns a signal for the specified gradient."
           },
           {
              "name":"SdfTwist",
              "description":"```\nShadersModule.sdfTwist(sdf: ShaderSignal, pivot: ShaderSignal, twist: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape twisted around the pivot by the given amount."
           },
           {
              "name":"functionVec3",
              "description":"```\nShadersModule.functionScalar(): ShaderSignal\nShadersModule.functionVec2(): ShaderSignal\nShadersModule.functionVec3(): ShaderSignal\nShadersModule.functionVec4(): ShaderSignal\n```\n\nReturns a signal for the identity function over the specified type."
           },
           {
              "name":"fragmentStage",
              "description":"```\nShadersModule.fragmentStage(val: ShaderSignal): ShaderSignal\n```\n\nPlaces the subsequent computation on val to the fragment stage."
           },
           {
              "name":"sdfRound",
              "description":"```\nShadersModule.sdfRound(sdf: ShaderSignal, radius: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape rounded by the specified radius."
           },
           {
              "name":"sdfMix",
              "description":"```\nShadersModule.sdfMix(sdf1: ShaderSignal, sdf2: ShaderSignal, alpha: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the linear interpolation of the two given SDF shapes, modulated by alpha."
           },
           {
              "name":"functionVec4",
              "description":"```\nShadersModule.functionScalar(): ShaderSignal\nShadersModule.functionVec2(): ShaderSignal\nShadersModule.functionVec3(): ShaderSignal\nShadersModule.functionVec4(): ShaderSignal\n```\n\nReturns a signal for the identity function over the specified type."
           },
           {
              "name":"sdfScale",
              "description":"```\nShadersModule.sdfScale(sdf: ShaderSignal, pivot: ShaderSignal, size: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape scaled around the given pivot by the given size."
           },
           {
              "name":"sdfDifference",
              "description":"```\nShadersModule.sdfDifference(sdf1: ShaderSignal, sdf2: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the difference of the two given SDF shapes."
           },
           {
              "name":"sdfUnion",
              "description":"```\nShadersModule.sdfUnion(sdf1: ShaderSignal, sdf2: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the union of the two given SDF shapes."
           },
           {
              "name":"sdfPolygon",
              "description":"```\nShadersModule.sdfPolygon(center: ShaderSignal, radius: ShaderSignal, numSides: ShaderSignal, {\"sdfVariant\": S.SdfVariant.EXACT}): ShaderSignal\n```\n\nReturns a signal for polygon SDF shape."
           },
           {
              "name":"sdfRectangle",
              "description":"```\nShadersModule.sdfRectangle(center: ShaderSignal, halfSize: ShaderSignal, {\"sdfVariant\": S.SdfVariant.EXACT}): ShaderSignal\n```\n\nReturns a signal for rectangle SDF shape."
           },
           {
              "name":"sdfFlip",
              "description":"```\nShadersModule.sdfFlip(sdf: ShaderSignal, offset: ShaderSignal, normal: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape flipped around the plane given by the offset an normal."
           },
           {
              "name":"sdfAnnular",
              "description":"```\nShadersModule.sdfAnnular(sdf: ShaderSignal, width: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the given SDF shape made annular (ring-like) by the specified width."
           },
           {
              "name":"sdfSmoothDifference",
              "description":"```\nShadersModule.sdfSmoothDifference(sdf1: ShaderSignal, sdf2: ShaderSignal, K: ShaderSignal): ShaderSignal\n```\n\nReturns a signal of the smooth difference of the two given SDF shapes, modulated by K."
           },
           {
              "name":"vertexAttribute",
              "description":"```\nShadersModule.vertexAttribute({\"variableName\": ShadersModule.VertexAttribute.TEX_COORDS}): ShaderSignal\n```\n\nReturns a signal for the specified vertex attribute."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"CanvasTexture",
        "scope":"TexturesModule",
        "description":"The `CanvasTexture` class enables painting with a brush to a texture.",
        "super":"TextureBase",
        "methods":[
           {
              "name":"clearPaths",
              "description":"```\nclearPaths(): void\n```\n\nDeletes all paths."
           },
           {
              "name":"addPath",
              "description":"```\naddPath(startProgress: ScalarSignal, endProgress: ScalarSignal, xSampler: ScalarSampler, ySampler: ScalarSampler, widthSampler: ScalarSampler, colorSampler: ColorSampler): void\n```\n\nAdds a path based on the specified samplers."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"ISignal",
        "scope":"ReactiveModule",
        "description":"The `ISignal` interface. The base class for `ScalarSignal`, `PointSignal`, `VectorSignal`, `BooleanSignal`, and `StringSignal`",
        "methods":[
           {
              "name":"valueOf",
              "description":"```\nvalueOf(): void\n```\n\nThrows an error. Signals are not supposed to be implicitly converted to scalar values.\n\n**See also**: `ScalarSignal.add`, `ScalarSignal.sub`, `ScalarSignal.mul`, `ScalarSignal.div`"
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"SequenceTexture",
        "scope":"TexturesModule",
        "description":"The `SequenceTexture` class is a collection of still images that form an animation.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"currentFrame",
              "description":"```\n(get) currentFrame: ScalarSignal\n(set) currentFrame: ScalarSignal\n```\n\nSpecifies the current frame in the animated sequence."
           }
        ]
     },
     {
        "name":"ColorSignal",
        "scope":"ReactiveModule",
        "description":"The `ColorSignal` class monitors a color.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ColorTexture",
        "scope":"TexturesModule",
        "description":"The `ColorTexture` class encapsulates a texture that has a color (including alpha channel).",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"color",
              "description":"```\n(get) color: (Not Available)\n(set) color: ColorSignal\n```\n\nSpecifies a `ColorSignal` for a solid color texture. A `ColorSignal` may be created using the `RGBA()` and `HSVA()` methods of the `Reactive` module.\n\n**See Also**: `ReactiveModule.RGBA` and `ReactiveModule.HSVA`."
           }
        ]
     },
     {
        "name":"PlanarDiv",
        "scope":"SceneModule",
        "description":"The `PlanarDiv` class describes a div on a plane.",
        "super":"PlanarObject",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"EulerAnglesSignal",
        "scope":"ReactiveModule",
        "description":"The `EulerAnglesSignal` class monitors Euler angle signal values.",
        "methods":[

        ],
        "properties":[
           {
              "name":"z",
              "description":"```\n(get) z: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Euler Z rotation."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Euler Y rotation."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Euler X rotation."
           }
        ]
     },
     {
        "name":"CameraTexture",
        "scope":"TexturesModule",
        "description":"The `CameraTexture` class.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"FaceAnchor",
        "scope":"SceneModule",
        "description":"The `FaceAnchor` class describes an anchored face.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"TransformSignal",
        "scope":"ReactiveModule",
        "description":"The `TransformSignal` class monitors a scene transform.",
        "super":"ISignal",
        "methods":[
           {
              "name":"delayBy",
              "description":"```\ndelayBy({milliseconds: number}): this\n```\nDelays a signal. The argument is an object with a \"milliseconds\" property specifying the delay duration in milliseconds."
           },
           {
              "name":"expSmooth",
              "description":"```\nexpSmooth(dampFactor: number): TransformSignal\n```\n\nSmoothes a variable signal using exponential averaging over time. The argument specifies the dampening time constant in milliseconds.\n\n**Note**: The smoothed transformation for a signal that specifies a rigid body transformation is guaranteed to be a rigid body transformation. The rotation component is smoothed in spherical coordinates using Slerp (spherical linear interpolation).\n\n**Note**: See also `ReactiveModule.expSmooth`."
           },
           {
              "name":"applyTo",
              "description":"```\napplyTo(transform: TransformSignal): TransformSignal\napplyTo(point: PointSignal): PointSignal\napplyTo(vector: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is equal to the value of the provided transformation/point/vector with the transformation of the current `TransformSignal` applied to it."
           },
           {
              "name":"inverse",
              "description":"```\ninverse(): TransformSignal\n```\n\nReturns a signal with the value that is equal to the inverted transformation value of the given signal at any point of time."
           }
        ],
        "properties":[
           {
              "name":"scale",
              "description":"```\n(get) scale: ScaleSignal\n(set) (Not Available)\n```\n\nRepresents scale in the local coordinate system."
           },
           {
              "name":"position",
              "description":"```\n(get) scale: PointSignal\n(set) (Not Available)\n```\n\nRepresents the offset in the local coordinate system."
           },
           {
              "name":"scaleZ",
              "description":"```\n(get) scaleZ: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents scale along the Z-axis of the local coordinate system."
           },
           {
              "name":"scaleY",
              "description":"```\n(get) scaleY: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents scale along the Y-axis of the local coordinate system."
           },
           {
              "name":"rotationZ",
              "description":"```\n(get) rotationZ: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents rotation about the Z-axis of the rotated local coordinate system, in radians. The signal value is in the range [-PI, PI].\n\n**Note**: The order of operations (rotations in particular) is the same as in `Transform`. The rotations are applied to the object in Z-Y-X order. The Z rotation is applied last to the object, therefore if the `rotationX` or `rotationY` is not zero, then `rotationZ` is applied not in the object's local coordinate system but in the rotated one."
           },
           {
              "name":"scaleX",
              "description":"```\n(get) scaleX: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents scale along the X-axis of the local coordinate system."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the offset along the X-axis of the local coordinate system."
           },
           {
              "name":"rotationX",
              "description":"```\n(get) rotationX: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents rotation about the X-axis of the local coordinate system, in radians. The signal value is in the range [-PI, PI].\n\n**Note**: The order of operations (rotations in particular) is the same as in `Transform`. The rotations are applied to the object in Z-Y-X order. The X rotation is applied first to the object, therefore it is always performed in the object's local coordinate system."
           },
           {
              "name":"rotationY",
              "description":"```\n(get) rotationY: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents rotation about the Y-axis of the rotated local coordinate system, in radians. The signal value is in the range [-PI/2, PI/2].\n\n**Note**: The order of operations (rotations in particular) is the same as in `Transform`. The rotations are applied to the object in Z-Y-X order. The Y rotation is applied second to the object, therefore if the `rotationX` is not zero, then `rotationY` is applied not in the object's local coordinate system but in the rotated one."
           },
           {
              "name":"z",
              "description":"```\n(get) z: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the offset along the Z-axis of the local coordinate system."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the offset along the Y-axis of the local coordinate system."
           }
        ]
     },
     {
        "name":"PixelPointSignal",
        "scope":"ReactiveModule",
        "description":"The `PixelPointSignal` class monitors a 2D coordinate.",
        "methods":[

        ],
        "properties":[
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the vertical coordinate, in pixels."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the horizontal coordinate, in pixels."
           }
        ]
     },
     {
        "name":"ScaleSignal",
        "scope":"ReactiveModule",
        "description":"The ScalarSignal class monitors an objects scale.",
        "methods":[
           {
              "name":"div",
              "description":"```\ndiv(other: ScaleSignal): ScaleSignal\n```\n\nReturns a signal with the value that is the element-wise division of the values of the given signals."
           },
           {
              "name":"mul",
              "description":"```\nmul(other: ScaleSignal): ScaleSignal\n```\n\nReturns a signal with the value that is the element-wise multiplication of the values of the given signals."
           }
        ],
        "properties":[
           {
              "name":"z",
              "description":"```\n  (get) z: ScalarSignal\n  (set) (Not Available)\n  ```\n\n  Represents the Z coordinate of the scale."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Y coordinate of the scale."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the X coordinate of the scale."
           }
        ]
     },
     {
        "name":"Mesh",
        "scope":"SceneModule",
        "description":"The `Mesh` class describes a scene mesh.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"prefabName",
              "description":"```\n(get) prefabName: String\n(set) (Not Available)\n```\n\nSpecifies the name of prefab for Mesh. This is the unique identifier of the prefab."
           },
           {
              "name":"materialIdentifier",
              "description":"```\n(get) materialIdentifier: String\n(set) (Not Available)\n```\n\nSpecifies the unique id of material for Mesh."
           },
           {
              "name":"material",
              "description":"```\n(get) material: MaterialBase\n(set) material: MaterialBase\n```\n\nSpecifies the material of the scene object."
           }
        ]
     },
     {
        "name":"StringValue",
        "scope":"ReactiveModule",
        "description":"The `StringValue` class contains a string value.",
        "methods":[
           {
              "name":"pinLastValue",
              "description":"```\npinLastValue(): ConstStringSignal\n```\n\nReturns a `ConstStringSignal` containing a constant value which is the last value of the specified signal before `pinLastValue` is called.\nConstStringSignal can be passed to a functions which accept strings."
           }
        ],
        "properties":[
           {
              "name":"lastValue",
              "description":"```\n(get) lastValue: string\n(set) (Not Available)\n```\n\nSpecifies a string representing the last value of the object."
           }
        ]
     },
     {
        "name":"SignalRecord",
        "scope":"AnimationModule",
        "description":"The `SignalRecord` class encapsulates recording data for a value signal",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"UnitsModule",
        "description":"The `UnitsModule` class provides functionality for converting values into world-space units.",
        "exampleCode":"const Diagnostics = require('Diagnostics');\nconst Units = require('Units');\n\nconst value = 5;\n\nDiagnostics.log(value + ' cm => ' + Units.cm(value));\nDiagnostics.log(value + ' ft => ' + Units.ft(value));",
        "super":"Module",
        "methods":[
           {
              "name":"yd",
              "description":"```\nyd(yards: number): number\n```\n\nConverts the specified yard value to world units."
           },
           {
              "name":"ft",
              "description":"```\nft(feet: number): number\n```\n\nConverts the specified foot value to world units."
           },
           {
              "name":"in",
              "description":"```\nin(inches: number): number\n```\n\nConverts the specified inch value to world units."
           },
           {
              "name":"m",
              "description":"```\nm(meters: number): number\n```\n\nConverts the specified meter value to world units."
           },
           {
              "name":"cm",
              "description":"```\ncm(centimeters: number): number\n```\n\nConverts the specified centimeter value to world units."
           },
           {
              "name":"mm",
              "description":"```\nmm(millimeters: number): number\n```\n\nConverts the specified millimeter value to world units."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"Bounds2D",
        "scope":"SceneModule",
        "description":"The `Bounds2D` class describes the bounds of a scene element.",
        "methods":[

        ],
        "properties":[
           {
              "name":"height",
              "description":"```\n(get) height: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the height of the scene element boundaries. Measured in 3D units."
           },
           {
              "name":"width",
              "description":"```\n(get) width: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the width of the scene element boundaries. Measured in 3D units."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the top boundary of the scene element. Relative to the parent object bounds. Measured in 3D units.\n\n**Note**: the offset is measured from the parent's top boundary, which might be different from the parent's origin."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the left boundary of the scene element. Relative to the parent object bounds. Measured in 3D units.\n\n**Note**: the offset is measured from the parent's left boundary, which might be different from the parent's origin."
           }
        ]
     },
     {
        "name":"HsvaSignal",
        "scope":"ReactiveModule",
        "description":"The `HsvaSignal` class monitors a HSVA color value.",
        "super":"ColorSignal",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"Point2DSignal",
        "scope":"ReactiveModule",
        "description":"The `Point2DSignal` class monitors a 2D coordinate, in normalized screen space units.",
        "super":"ISignal",
        "methods":[
           {
              "name":"cross",
              "description":"```\nVectorSignal.cross(other: VectorSignal): VectorSignal\n```\n\nReturns a vector signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"round",
              "description":"```\nScalarSignal.round(): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ReactiveModule.round`"
           },
           {
              "name":"floor",
              "description":"```\nScalarSignal.floor(): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.floor`"
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"dot",
              "description":"```\nVectorSignal.dot(other: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"magnitude",
              "description":"```\nVectorSignal.magnitude(): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"atan2",
              "description":"```\nScalarSignal.atan2(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ReactiveModule.atan2`"
           },
           {
              "name":"mod",
              "description":"```\nScalarSignal.mod(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ReactiveModule.mod`"
           },
           {
              "name":"sub",
              "description":"```\nScalarSignal.sub(other: ScalarSignal): ScalarSignal\nPointSignal.sub(other: PointSignal): VectorSignal\nPointSignal.sub(other: VectorSignal): PointSignal\nVectorSignal.sub(other: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ReactiveModule.sub`, `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nScalarSignal.mul(other: ScalarSignal): ScalarSignal\nScalarSignal.mul(other: VectorSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ReactiveModule.mul`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"add",
              "description":"```\nScalarSignal.add(other: ScalarSignal): ScalarSignal\nPointSignal.add(other: VectorSignal): PointSignal\nVectorSignal.add(other: VectorSignal): VectorSignal\nVectorSignal.add(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"pow",
              "description":"```\nScalarSignal.pow(exponent: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\n\nRaising a negative base to the power of a fractional exponent produce a NaN.\nRaising 0 to the power of a negative exponent will produce positive infinity.\nRaising 0 to the power of any positive exponent will produce 0.\nRaising -1 to the power of a positive or negative infinity exponent will produce 1.\nRaising 1 to the power of any exponent, including NaN, will produce 1.\nRaising any base, including NaN, to the power of 0 will produce 1.\nRaising any base to the power of negative infinity, where |base| < 1, will produce positive infinity.\nRaising any base to the power of negative infinity, where |base| > 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| < 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| > 1, will produce positive infinity.\nRaising negative infinity to the power of a negative exponent will produce 0.\nRaising negative infinity to the power of a positive exponent will produce positive infinity.\nRaising positive infinity to the power of a negative exponent will produce 0.\nRaising positive infinity to the power of a positive exponent will produce positive infinity.\n\nIn all other cases, if either the base or the exponent is a NaN, a NaN will be produced.\n\n**See Also**: `ReactiveModule.pow`"
           },
           {
              "name":"sum",
              "description":"```\nScalarSignal.sum(other: ScalarSignal): ScalarSignal\nPointSignal.sum(other: VectorSignal): PointSignal\nVectorSignal.sum(other: VectorSignal): VectorSignal\nVectorSignal.sum(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"distance",
              "description":"```\nPointSignal.distance(other: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"sign",
              "description":"```\nScalarSignal.sign(): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ReactiveModule.sign`"
           },
           {
              "name":"div",
              "description":"```\nScalarSignal.div(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ReactiveModule.div`"
           },
           {
              "name":"sqrt",
              "description":"```\nScalarSignal.sqrt(): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ReactiveModule.sqrt`"
           },
           {
              "name":"neg",
              "description":"```\nScalarSignal.neg(): ScalarSignal\nVectorSignal.neg(): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ReactiveModule.neg`, `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"abs",
              "description":"```\nScalarSignal.abs(): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ReactiveModule.abs`"
           },
           {
              "name":"ceil",
              "description":"```\nScalarSignal.ceil(): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.ceil`"
           }
        ],
        "properties":[
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the vertical coordinate, in normalized screen space units."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the horizontal coordinate, in normalized screen space units."
           }
        ]
     },
     {
        "name":"DynamicExtrusion",
        "scope":"SceneModule",
        "description":"The `DynamicExtrusion` class provides functionality for creating extruded 3D objects using a brush.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ArrayOfScalarSignals",
        "scope":"AnimationModule",
        "description":"The `ArrayOfScalarSignals` class describes an array of scalar signals.",
        "methods":[
           {
              "name":"get",
              "description":"```\nget(index: number): ScalarSignal\n```\n\nReturns the signal indicated by the `index` parameter."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"Point3D",
        "scope":"ReactiveModule",
        "description":"The `Point3D` class contains a 3D coordinate.",
        "methods":[

        ],
        "properties":[
           {
              "name":"z",
              "description":"```\n(get) z: number\n(set) z: number\n```\n\nSpecifies the z  coordinate."
           },
           {
              "name":"y",
              "description":"```\n(get) y: number\n(set) y: number\n```\n\nSpecifies the y coordinate."
           },
           {
              "name":"x",
              "description":"```\n(get) x: number\n(set) x: number\n```\n\nSpecifies the x coordinate."
           }
        ]
     },
     {
        "name":"TextureBase",
        "scope":"TexturesModule",
        "description":"The `TextureBase` class describes a texture.",
        "methods":[

        ],
        "properties":[
           {
              "name":"height",
              "description":"```\n(get) height: ScalarSignal\n```\n\nGets the height of the texture in pixels."
           },
           {
              "name":"width",
              "description":"```\n(get) width: ScalarSignal\n```\n\nGets the width of the texture in pixels."
           },
           {
              "name":"identifier",
              "description":"```\n(get) identifier: String\n(set) (Not Available)\n```\n\nSpecifies the unique texture identifier. This value is specified internally in AR Studio."
           },
           {
              "name":"signal",
              "description":"```\n(get) component: TextureSignal\n```\n\nGets the TODO of the texture in pixels."
           },
           {
              "name":"name",
              "description":"```\n(get) name: String\n(set) (Not Available)\n```\n\nSpecifies the unique texture name. The texture name is specified in AR Studio at design time.\n\n**See Also**: `TexturesModule.get`."
           }
        ]
     },
     {
        "name":"Subscription",
        "scope":"ReactiveModule",
        "description":"The `Subscription` class implements object value monitoring.",
        "methods":[
           {
              "name":"unsubscribe",
              "description":"```\nunsubscribe(): void\n```\n\nUnsubscribes the previously subscribed callback from the `EventSource`.\n\n**See Also**: `EventSource.subscribe`, `EventSource.subscribeOnNext`."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"RotationSignal",
        "scope":"ReactiveModule",
        "description":"The `RotationSignal` class monitors rotation values.",
        "super":"ISignal",
        "methods":[

        ],
        "properties":[
           {
              "name":"eulerAngles",
              "description":"```\n(get) euler: EulerAnglesSignal\n(set) (Not Available)\n```\nRepresents the Euler angle from the `RotationSignal`.\n\n**Note**: the order of rotations for the Euler angles is the same as in `Transformation` class."
           }
        ]
     },
     {
        "name":"ReactiveModule",
        "description":"The `ReactiveModule` class exposes methods for reactive programming.",
        "super":"Module",
        "methods":[
           {
              "name":"distance",
              "description":"```\nReactiveModule.distance(v1: PointSignal, v2: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"cross",
              "description":"```\nReactiveModule.cross(v1: VectorSignal, v2: VectorSignal): VectorSignal\n```\n\nReturns a scalar signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"dot",
              "description":"```\nReactiveModule.dot(v1: VectorSignal, v2: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"magnitude",
              "description":"```\nReactiveModule.magnitude(v: VectorSignal): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"clamp",
              "description":"```\nReactiveModule.clamp(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the given `x` signal constrained to lie between the values of the given `min` and `max` signals.\n\n**Note**: The behavior is undefined if `min` is greater than `max`."
           },
           {
              "name":"step",
              "description":"```\nReactiveModule.step(x: ScalarSignal, edge: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge, and 1.0 is returned otherwise."
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"max",
              "description":"```\nReactiveModule.max(x: ScalarSignal, y: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the greater of the values of the given signals."
           },
           {
              "name":"atan2",
              "description":"```\nReactiveModule.atan2(y: ScalarSignal, x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ScalarSignal.atan2`"
           },
           {
              "name":"mod",
              "description":"```\nReactiveModule.mod(x: ScalarSignal, y: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ScalarSignal.mod`"
           },
           {
              "name":"div",
              "description":"```\nReactiveModule.div(x: ScalarSignal, y: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ScalarSignal.div`"
           },
           {
              "name":"sub",
              "description":"```\nReactiveModule.sub(x: ScalarSignal, y: ScalarSignal): ScalarSignal\nReactiveModule.sub(x: PointSignal, y: VectorSignal): PointSignal\nReactiveModule.sub(x: VectorSignal, y: VectorSignal): VectorSignal\nReactiveModule.sub(x: PointSignal, y: PointSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nReactiveModule.mul(x: ScalarSignal, y: ScalarSignal): ScalarSignal\nReactiveModule.mul(x: VectorSignal, y: ScalarSignal): VectorSignal\nReactiveModule.mul(x: ScalarSignal, y: VectorSignal): VectorSignal\nReactiveModule.mul(x: VectorSignal, y: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"add",
              "description":"```\nadd(x: ScalarSignal, y: ScalarSignal): ScalarSignal\nadd(x: PointSignal, y: VectorSignal): PointSignal\nadd(x: VectorSignal, y: PointSignal): PointSignal\nadd(x: VectorSignal, y: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ReactiveModule.sum`, `ScalarSignal.add`, `PointSignal.add`, `VectorSignal.add`"
           },
           {
              "name":"sign",
              "description":"```\nReactiveModule.sign(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ScalarSignal.sign`"
           },
           {
              "name":"abs",
              "description":"```\nReactiveModule.abs(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ScalarSignal.abs`"
           },
           {
              "name":"sqrt",
              "description":"```\nReactiveModule.sqrt(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ScalarSignal.sqrt`"
           },
           {
              "name":"log",
              "description":"```\nReactiveModule.log(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the natural logarithm of the value of the given signal."
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"antiderivative",
              "description":"```\nantiderivative(signal: ScalarSignal, {min: number, max: number, initialValue: number, overflowBehaviour: ReactiveModule.AntiderivativeOverflowBehaviour}): ScalarSignal\n```\n\nReturns a signal that estimates the anti derivative of the given signal with respect to time (measured in milliseconds).\n\n**Note**: Since the antiderivative is inherently unbound the min/max parameters must be provided to prevent overflow. when `overflowBehaviour` is CLAMP the output is clamped at the min/max. When `overflowBehaviour` is WRAP the output is wrapped. This is useful when the output represents something that is cyclic like an angle in this case min might be 0, max might be 2*PI."
           },
           {
              "name":"atan",
              "description":"```\nReactiveModule.atan(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the inverse tangent of the value of the given signal (interpreted as radians)."
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"acos",
              "description":"```\nReactiveModule.acos(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the inverse cosine of the value of the given signal (interpreted as radians)."
           },
           {
              "name":"cos",
              "description":"```\nReactiveModule.cos(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the cosine of the value of the given signal (interpreted as radians)."
           },
           {
              "name":"sin",
              "description":"```\nReactiveModule.sin(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the sine of the value of the given signal (interpreted as radians)."
           },
           {
              "name":"xorList",
              "description":"```\nxorList(x: Array<BoolSignal>): BoolSignal\n```\n\nReturns a signal with the value that is the logical xor of the values in an array"
           },
           {
              "name":"or",
              "description":"```\nor(lhs: BoolSignal, rhs: BoolSignal): BoolSignal\n```\n\nReturns a signal with the value that is the logical disjunction of the values of the given signals. It is `true` every time at least one of the input signals is `true` and `false` at all other times.\n\n**See Also**: `BoolSignal.or`"
           },
           {
              "name":"tan",
              "description":"```\nReactiveModule.tan(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the tangent of the value of the given signal (interpreted as radians)."
           },
           {
              "name":"val",
              "description":"```\n  val(constant: number): ScalarSignal\n  val(constant: string): StringSignal\n  val(constant: boolean): BoolSignal\n  ```\n\n  Returns a signal that has a constant value which is specified by the argument.\n\n  **Note**: Primitive types are implicitly converted to constant signals when passed as function or property-setter arguments, therefore using `val` in such scenarios is not required."
           },
           {
              "name":"and",
              "description":"```\n and(lhs: BoolSignal, rhs: BoolSignal): BoolSignal\n ```\n\n Returns a signal with the value that is the logical conjunction of the values of the given signals. It is `true` every time both input signals are `true` and `false` at all other times.\n\n **See Also**: `BoolSignal.and`"
           },
           {
              "name":"asin",
              "description":"```\nReactiveModule.asin(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the inverse sine of the value of the given signal (interpreted as radians)."
           },
           {
              "name":"min",
              "description":"```\nReactiveModule.min(x: ScalarSignal, y: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the lesser of the values of the given signals."
           },
           {
              "name":"pow",
              "description":"```\nReactiveModule.pow(b: ScalarSignal, n: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\nFor further details on behavior relating to mathematical edge cases, see `ScalarSignal.pow`.\n\n**See Also**: `ScalarSignal.pow`"
           },
           {
              "name":"monitorMany",
              "description":"```\nmonitorMany(signals: { [string]: ScalarSignal}): EventSource\nmonitorMany(signals: { [string]: ScalarSignal}, config: {fireOnInitialValue: ?boolean}): EventSource\n```\n\nReturns an `EventSource` that emits an event every time when any value of the input signals change. The event contains a JSON object with the old and new values in the format:\n\n```\n{ \"oldValues\": oldValues, \"newValues\": newValues }\n```\n\nwhere `oldValues` and `newValues` are the JSON objects where keys are the names of the signals and values are old or new values of that signals correspondingly.\n\n**Note**: By default, there is no event fired for the initial value of the signal. If `config.fireOnInitialValue` is set to `true` then an event for initial signal value is also emitted. `oldValues` is unset for this initial event.\n\n**See Also**: `ReactiveModule.monitor`"
           },
           {
              "name":"derivative",
              "description":"```\nderivative(): ScalarSignal\n```\n\nReturns a signal that estimates the derivative of the given signal with respect to time (measured in milliseconds).\n\n**Note**: the value of the derivative at the initial point of time is always set to zero.\n\n**Note**: the returned signal might be noisy for certain types of input signals, especially those received from the face tracking. It is recommended to pass the input signal to `expSmooth` first with a damping constant in the range between 100 and 500."
           },
           {
              "name":"ceil",
              "description":"```\nReactiveModule.ceil(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ScalarSignal.ceil`"
           },
           {
              "name":"gt",
              "description":"```\ngt(lhs: ScalarSignal, rhs: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is strictly **greater than** the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ScalarSignal.gt`"
           },
           {
              "name":"scale",
              "description":"```\nscale(x: ScalarSignal, y: ScalarSignal, z: ScalarSignal): ScaleSignal\n```\n\nCombines three signals and returns the result as a `ScaleSignal`."
           },
           {
              "name":"vector",
              "description":"```\nvector(x: ScalarSignal, y: ScalarSignal, z: ScalarSignal): VectorSignal\n```\n\nCombines three signals and returns the result as a `VectorSignal`."
           },
           {
              "name":"rotation",
              "description":"```\nrotation(w: number, x: number, y: number, z: number): Rotation\n```\n\nCreates 'Rotation' from quaternion components."
           },
           {
              "name":"mulList",
              "description":"```\nmulList(x: Array<number>): ScalarSignal\n```\n\nReturns a signal with the value that is the product of the values in an array"
           },
           {
              "name":"sum",
              "description":"```\nsum(x: ScalarSignal, y: ScalarSignal): ScalarSignal\nsum(x: PointSignal, y: VectorSignal): PointSignal\nsum(x: VectorSignal, y: PointSignal): PointSignal\nsum(x: VectorSignal, y: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ReactiveModule.sum`, `ScalarSignal.add`, `PointSignal.add`, `VectorSignal.add`"
           },
           {
              "name":"point2d",
              "description":"```\npoint2d(x: ScalarSignal, y: ScalarSignal): PixelPointSignal\n```\n\nCombines two signals and returns the result as a `PixelPointSignal`."
           },
           {
              "name":"eq",
              "description":"```\n  eq(lhs: ScalarSignal, rhs: ScalarSignal): BoolSignal\n  eq(lhs: StringSignal, rhs: StringSignal): BoolSignal\n  eq(lhs: BoolSignal, rhs: BoolSignal): BoolSignal\n  ```\n\n  Returns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n  **Note**: the scalar values are tested for exact equality. For some applications it might be reasonable to perform a non-strict comparison allowing the values to be within a small distance one from another.\n\n  **See Also**: `ScalarSignal.eq`, `StringSignal.eq`, `BoolSignal.eq`"
           },
           {
              "name":"ne",
              "description":"```\n  ne(lhs: ScalarSignal, rhs: ScalarSignal): BoolSignal\n  ne(lhs: StringSignal, rhs: StringSignal): BoolSignal\n  ne(lhs: BoolSignal, rhs: BoolSignal): BoolSignal\n  ```\n\n  Returns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **not equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n  **Note**: the scalar values are tested for exact equality. For some applications it might be reasonable to perform a non-strict comparison allowing the values to be within a small distance one from another.\n\n  **See Also**: `ScalarSignal.ne`, `StringSignal.ne`, `BoolSignal.ne`"
           },
           {
              "name":"point",
              "description":"```\npoint(x: ScalarSignal, y: ScalarSignal, z: ScalarSignal): PointSignal\n```\n\nCombines three signals and returns the result as a `PointSignal`."
           },
           {
              "name":"le",
              "description":"```\nle(lhs: ScalarSignal, rhs: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **less than or equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ScalarSignal.le`"
           },
           {
              "name":"pack4",
              "description":"```\nReactiveModule.pack4(x: ScalarSignal, y: ScalarSignal, z: ScalarSignal, w: ScalarSignal): Vec4Signal\n```\n\nPacks four Scalar signals into a Vec4 signal."
           },
           {
              "name":"expSmooth",
              "description":"```\nexpSmooth(signal: ScalarSignal, dampFactor: number): ScalarSignal\nexpSmooth(signal: PointSignal, dampFactor: number): PointSignal\nexpSmooth(signal: VectorSignal, dampFactor: number): VectorSignal\nexpSmooth(signal: TransformSignal, dampFactor: number): TransformSignal\n```\n\nSmoothes a variable signal using exponential averaging over time. The argument specifies the dampening time constant in milliseconds.\n\n**Note**: See also `ScalarSignal.expSmooth`, `PointSignal.expSmooth`, `VectorSignal.expSmooth`, `TransformSignal.expSmooth`.\n\n**Note**: The smoothed transformation for a signal that specifies a rigid body transformation is guaranteed to be a rigid body transformation. The rotation component is smoothed in spherical coordinates using Slerp (spherical linear interpolation)."
           },
           {
              "name":"ge",
              "description":"```\nge(lhs: ScalarSignal, rhs: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **greater than or equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ScalarSignal.ge`"
           },
           {
              "name":"andList",
              "description":"```\nandList(x: Array<BoolSignal>): BoolSignal\n```\n\nReturns a signal with the value that is the logical and of the values in an array"
           },
           {
              "name":"concat",
              "description":"```\nconcat(lhs: StringSignal, rhs: StringSignal): StringSignal\n```\n\nReturns a `StringSignal` containing the concatenation of the values specified by the input signals.\n\n**See Also**: `StringSignal.concat`"
           },
           {
              "name":"HSVA",
              "description":"```\nHSVA(h: ScalarSignal, s: ScalarSignal, v: ScalarSignal, a: ScalarSignal): HsvaSignal\n```\n\nCombines four signals and returns the result as an `HsvaSignal`. Each value should be in the range between 0.0 and 1.0.\n\n**Note**: Hue value is also specified in the range between 0.0 and 1.0."
           },
           {
              "name":"xor",
              "description":"```\nxor(lhs: BoolSignal, rhs: BoolSignal): BoolSignal\n```\n\nReturns a signal with the value that is the logical exclusive disjunction of the values of the given signals. It is `true` every time exactly one of the input signals is `true` and `false` at all other times.\n\n**Note**: It is equivalent to `ReactiveModule.ne`.\n\n**See Also**: `BoolSignal.xor`"
           },
           {
              "name":"once",
              "description":"```\nonce(): EventSource\n```\n\nReturns an `EventSource` that emits exactly one empty event as soon as possible."
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"neg",
              "description":"```\nReactiveModule.neg(x: ScalarSignal): ScalarSignal\nReactiveModule.neg(x: VectorSignal): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"sumList",
              "description":"```\nsumList(x: Array<number>): ScalarSignal\n```\n\nReturns a signal with the value that is the sum of the values in an array"
           },
           {
              "name":"schmittTrigger",
              "description":"```\n  schmittTrigger(signal: ScalarSignal, config: { low: number, high: number, initialValue: ?boolean}): BoolSignal\n  ```\n\n  Returns a Boolean signal that is `true` when the input is strictly greater than the upper threshold, and `false` when it is strictly less than the lower threshold.\n  For input values between and including the thresholds, the Shmitt trigger returns the same value as at the previous update, or **initialValue** if this is the first update.\n\n  **Note**: The initialValue is assumed to be `false` if it isn't specified."
           },
           {
              "name":"lt",
              "description":"```\nlt(lhs: ScalarSignal, rhs: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is strictly **less than** the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ScalarSignal.lt`"
           },
           {
              "name":"pack2",
              "description":"```\nReactiveModule.pack2(x: ScalarSignal, y: ScalarSignal): Vec2Signal\nReactiveModule.pack2(x: ScalarSignal, y: Vec2Signal): Vec3Signal\nReactiveModule.pack2(x: Vec2Signal, y: ScalarSignal): Vec3Signal\nReactiveModule.pack2(x: ScalarSignal, y: Vec3Signal): Vec4Signal\nReactiveModule.pack2(x: Vec3Signal, y: ScalarSignal): Vec4Signal\nReactiveModule.pack2(x: Vec2Signal, y: Vec2Signal): Vec4Signal\n```\n\nPacks two Scalar or Vector signals into a bigger Vector signal."
           },
           {
              "name":"floor",
              "description":"```\nReactiveModule.floor(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ScalarSignal.floor`"
           },
           {
              "name":"RGBA",
              "description":"```\nRGBA(r: ScalarSignal, g: ScalarSignal, b: ScalarSignal, a: ScalarSignal): RgbaSignal\n```\n\nCombines four signals and returns the result as an `RgbaSignal`. Each value should be in the range between 0.0 and 1.0.\n\n**Note**: RGB components are interpreted in sRGB space."
           },
           {
              "name":"mix",
              "description":"```\nReactiveModule.mix(x: ScalarSignal, y: ScalarSignal, alpha: ScalarSignal): ScalarSignal\nReactiveModule.mix(x: PointSignal, y: PointSignal, alpha: ScalarSignal): PointSignal\nReactiveModule.mix(x: VectorSignal, y: VectorSignal, alpha: ScalarSignal): VectorSignal\nReactiveModule.mix(x: TransformSignal, y: TransformSignal, alpha: ScalarSignal): TransformSignal\n```\nReturns a signal with the value that is the interpolation of the values of the given signals."
           },
           {
              "name":"round",
              "description":"```\nReactiveModule.round(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ScalarSignal.round`"
           },
           {
              "name":"exp",
              "description":"```\nReactiveModule.exp(x: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is e (the Euler's constant 2.718...) to the power of the value of the given signal."
           },
           {
              "name":"orList",
              "description":"```\norList(x: Array<BoolSignal>): BoolSignal\n```\n\nReturns a signal with the value that is the logical or of the values in an array"
           },
           {
              "name":"pack3",
              "description":"```\nReactiveModule.pack3(x: ScalarSignal, y: ScalarSignal, z: ScalarSignal): Vec3Signal\nReactiveModule.pack3(x: ScalarSignal, y: ScalarSignal, z: Vec2Signal): Vec4Signal\nReactiveModule.pack3(x: ScalarSignal, y: Vec2Signal, z: ScalarSignal): Vec4Signal\nReactiveModule.pack3(x: Vec2Signal, y: ScalarSignal, z: ScalarSignal): Vec4Signal\n```\n\nPacks three Scalar or Vector signals into a bigger Vector signal."
           },
           {
              "name":"not",
              "description":"```\nnot(signal: BoolSignal): BoolSignal\n```\n\nReturns a signal with the logically negated value of the given signal.\n\n**See Also**: `BoolSignal.not`"
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"ScalarValue",
        "scope":"ReactiveModule",
        "description":"The `ScalarValue` class contains a scalar value.",
        "methods":[
           {
              "name":"pinLastValue",
              "description":"```\npinLastValue(): ConstScalarSignal\n```\n\nReturns a `ConstScalarSignal` containing a constant value which is the last value of the specified signal before `pinLastValue` is called.\nConstScalarSignal can be passed to a functions which accept numbers."
           }
        ],
        "properties":[
           {
              "name":"lastValue",
              "description":"```\n(get) lastValue: number\n(set) (Not Available)\n```\n\nSpecifies a number representing the last value of the object."
           }
        ]
     },
     {
        "name":"PointSignal",
        "scope":"ReactiveModule",
        "description":"The PointSignal class monitors a 3D coordinate.",
        "super":"ISignal",
        "methods":[
           {
              "name":"delayBy",
              "description":"```\ndelayBy({milliseconds: number}): this\n```\nDelays a signal. The argument is an object with a \"milliseconds\" property specifying the delay duration in milliseconds."
           },
           {
              "name":"distance",
              "description":"```\nPointSignal.distance(other: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"cross",
              "description":"```\nVectorSignal.cross(other: VectorSignal): VectorSignal\n```\n\nReturns a vector signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"floor",
              "description":"```\nScalarSignal.floor(): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.floor`"
           },
           {
              "name":"round",
              "description":"```\nScalarSignal.round(): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ReactiveModule.round`"
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"dot",
              "description":"```\nVectorSignal.dot(other: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"magnitude",
              "description":"```\nVectorSignal.magnitude(): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"atan2",
              "description":"```\nScalarSignal.atan2(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ReactiveModule.atan2`"
           },
           {
              "name":"mod",
              "description":"```\nScalarSignal.mod(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ReactiveModule.mod`"
           },
           {
              "name":"sub",
              "description":"```\nScalarSignal.sub(other: ScalarSignal): ScalarSignal\nPointSignal.sub(other: PointSignal): VectorSignal\nPointSignal.sub(other: VectorSignal): PointSignal\nVectorSignal.sub(other: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ReactiveModule.sub`, `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nScalarSignal.mul(other: ScalarSignal): ScalarSignal\nScalarSignal.mul(other: VectorSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ReactiveModule.mul`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"add",
              "description":"```\nScalarSignal.add(other: ScalarSignal): ScalarSignal\nPointSignal.add(other: VectorSignal): PointSignal\nVectorSignal.add(other: VectorSignal): VectorSignal\nVectorSignal.add(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"pow",
              "description":"```\nScalarSignal.pow(exponent: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\n\nRaising a negative base to the power of a fractional exponent produce a NaN.\nRaising 0 to the power of a negative exponent will produce positive infinity.\nRaising 0 to the power of any positive exponent will produce 0.\nRaising -1 to the power of a positive or negative infinity exponent will produce 1.\nRaising 1 to the power of any exponent, including NaN, will produce 1.\nRaising any base, including NaN, to the power of 0 will produce 1.\nRaising any base to the power of negative infinity, where |base| < 1, will produce positive infinity.\nRaising any base to the power of negative infinity, where |base| > 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| < 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| > 1, will produce positive infinity.\nRaising negative infinity to the power of a negative exponent will produce 0.\nRaising negative infinity to the power of a positive exponent will produce positive infinity.\nRaising positive infinity to the power of a negative exponent will produce 0.\nRaising positive infinity to the power of a positive exponent will produce positive infinity.\n\nIn all other cases, if either the base or the exponent is a NaN, a NaN will be produced.\n\n**See Also**: `ReactiveModule.pow`"
           },
           {
              "name":"sum",
              "description":"```\nScalarSignal.sum(other: ScalarSignal): ScalarSignal\nPointSignal.sum(other: VectorSignal): PointSignal\nVectorSignal.sum(other: VectorSignal): VectorSignal\nVectorSignal.sum(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"sign",
              "description":"```\nScalarSignal.sign(): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ReactiveModule.sign`"
           },
           {
              "name":"div",
              "description":"```\nScalarSignal.div(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ReactiveModule.div`"
           },
           {
              "name":"sqrt",
              "description":"```\nScalarSignal.sqrt(): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ReactiveModule.sqrt`"
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"abs",
              "description":"```\nScalarSignal.abs(): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ReactiveModule.abs`"
           },
           {
              "name":"neg",
              "description":"```\nScalarSignal.neg(): ScalarSignal\nVectorSignal.neg(): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ReactiveModule.neg`, `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"ceil",
              "description":"```\nScalarSignal.ceil(): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.ceil`"
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"expSmooth",
              "description":"```\nexpSmooth(dampFactor: number): PointSignal\n```\n\nSmoothes a variable signal using exponential averaging over time. The argument specifies the dampening time constant in milliseconds.\n\n**Note**: See also `ReactiveModule.expSmooth`."
           }
        ],
        "properties":[
           {
              "name":"z",
              "description":"```\n(get) z: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Z coordinate of the point."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Y coordinate of the point."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the X coordinate of the point."
           }
        ]
     },
     {
        "name":"RgbaSignal",
        "scope":"ReactiveModule",
        "description":"The `RgbaSignal` class monitors a RGBA color value.",
        "super":"ColorSignal",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"OutputVisibility",
        "scope":"SceneModule",
        "description":"The `OutputVisibility` class describes whether or not an object is visible from various outputs.",
        "methods":[

        ],
        "properties":[
           {
              "name":"forOverlayOutput",
              "description":"```\n(get) forOverlayOutput: BoolValue\n(set) forOverlayOutput: BoolSignal\n```\n\nSpecifies whether the object is visible on the overlay output."
           },
           {
              "name":"forCaptureOutput",
              "description":"```\n(get) forCaptureOutput: BoolValue\n(set) forCaptureOutput: BoolSignal\n```\n\nSpecifies whether the object is visible on the capture output."
           },
           {
              "name":"forPreviewOutput",
              "description":"```\n(get) forPreviewOutput: BoolValue\n(set) forPreviewOutput: BoolSignal\n```\n\nSpecifies whether the object is visible on the preview output."
           }
        ]
     },
     {
        "name":"ScalarSignal",
        "scope":"ReactiveModule",
        "description":"The `ScalarSignal` class monitors a numerical value.",
        "exampleCode":"// Load in the required modules\n  const Animation = require('Animation');\n  const Scene = require('Scene');\n  const TouchGestures = require('TouchGestures');\n\n  // Access a plane inserted in the scene\n  const plane = Scene.root.find('plane0');\n\n  // Use pinLastValue as a way of getting the intial Y position of the plane\n  const planeInitialYPosition = plane.transform.y.pinLastValue();\n  // Define an end value using the negative Y value of the plane\n  const planeEndYPosition = plane.transform.y.mul(-1).pinLastValue();\n\n  // Create a timeDriver to set the duration of our animation\n  const timeDriver = Animation.timeDriver({durationMilliseconds: 5000});\n  // Create a linear sampler using the positions defined above as the start and end points\n  let linearSampler = Animation.samplers.linear(planeInitialYPosition,planeEndYPosition);\n\n  // Bind the Y position of the plane to an animation using the driver and sampler and\n  // start the timeDriver\n  plane.transform.y = Animation.animate(timeDriver,linearSampler);\n  timeDriver.start();\n\n  // Register a tap event on the plane\n  TouchGestures.onTap(plane).subscribe(function() {\n    // Redefine the linear sampler using the last Y value of the plane and the intial y value stored earlier\n    linearSampler = Animation.samplers.linear(plane.transform.y.pinLastValue(), planeInitialYPosition);\n    // Bind the Y position of the plane to an animation using the updated sampler and reset the time driver\n    plane.transform.y = Animation.animate(timeDriver,linearSampler);\n    timeDriver.reset();\n  });",
        "super":"ISignal",
        "methods":[
           {
              "name":"distance",
              "description":"```\nPointSignal.distance(other: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"pow",
              "description":"```\nScalarSignal.pow(exponent: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\n\nRaising a negative base to the power of a fractional exponent produce a NaN.\nRaising 0 to the power of a negative exponent will produce positive infinity.\nRaising 0 to the power of any positive exponent will produce 0.\nRaising -1 to the power of a positive or negative infinity exponent will produce 1.\nRaising 1 to the power of any exponent, including NaN, will produce 1.\nRaising any base, including NaN, to the power of 0 will produce 1.\nRaising any base to the power of negative infinity, where |base| < 1, will produce positive infinity.\nRaising any base to the power of negative infinity, where |base| > 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| < 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| > 1, will produce positive infinity.\nRaising negative infinity to the power of a negative exponent will produce 0.\nRaising negative infinity to the power of a positive exponent will produce positive infinity.\nRaising positive infinity to the power of a negative exponent will produce 0.\nRaising positive infinity to the power of a positive exponent will produce positive infinity.\n\nIn all other cases, if either the base or the exponent is a NaN, a NaN will be produced.\n\n**See Also**: `ReactiveModule.pow`"
           },
           {
              "name":"atan2",
              "description":"```\nScalarSignal.atan2(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ReactiveModule.atan2`"
           },
           {
              "name":"div",
              "description":"```\nScalarSignal.div(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ReactiveModule.div`"
           },
           {
              "name":"sub",
              "description":"```\nScalarSignal.sub(other: ScalarSignal): ScalarSignal\nPointSignal.sub(other: PointSignal): VectorSignal\nPointSignal.sub(other: VectorSignal): PointSignal\nVectorSignal.sub(other: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ReactiveModule.sub`, `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nScalarSignal.mul(other: ScalarSignal): ScalarSignal\nScalarSignal.mul(other: VectorSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ReactiveModule.mul`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"sum",
              "description":"```\nScalarSignal.sum(other: ScalarSignal): ScalarSignal\nPointSignal.sum(other: VectorSignal): PointSignal\nVectorSignal.sum(other: VectorSignal): VectorSignal\nVectorSignal.sum(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"add",
              "description":"```\nScalarSignal.add(other: ScalarSignal): ScalarSignal\nPointSignal.add(other: VectorSignal): PointSignal\nVectorSignal.add(other: VectorSignal): VectorSignal\nVectorSignal.add(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"monitor",
              "description":"```\nmonitor(): EventSource\nmonitor(config: { fireOnInitialValue: ?boolean}): EventSource\n```\n\nReturns an `EventSource` that emits an event every time the value of the input signal changes. The event contains a JSON object with the old and new values in the format:\n\n```\n{ \"oldValue\": val, \"newValue\": val }\n```\n\n**Note**: By default, there is no event fired for the initial value of the signal. If `config.fireOnInitialValue` is set to `true` then an event for initial signal value is also emitted. `oldValue` is unset for this initial event."
           },
           {
              "name":"format",
              "description":"```\nformat(formatString: string): StringSignal\n```\n\nConverts a `ScalarSignal` to a `StringSignal` according to the supplied formatting string.\n\n**Note**: `formatString` shall conform to the Folly formatting rules as specified here: https://github.com/facebook/folly/blob/master/folly/docs/Format.md#format-string-syntax .\n\n**See Also**: `ScalarSignal.toString`."
           },
           {
              "name":"sqrt",
              "description":"```\nScalarSignal.sqrt(): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ReactiveModule.sqrt`"
           },
           {
              "name":"sign",
              "description":"```\nScalarSignal.sign(): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ReactiveModule.sign`"
           },
           {
              "name":"abs",
              "description":"```\nScalarSignal.abs(): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ReactiveModule.abs`"
           },
           {
              "name":"dot",
              "description":"```\nVectorSignal.dot(other: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"round",
              "description":"```\nScalarSignal.round(): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ReactiveModule.round`"
           },
           {
              "name":"floor",
              "description":"```\nScalarSignal.floor(): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.floor`"
           },
           {
              "name":"neg",
              "description":"```\nScalarSignal.neg(): ScalarSignal\nVectorSignal.neg(): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ReactiveModule.neg`, `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"multiTrigger",
              "description":"```\nmultiTrigger(threshold: number): EventSource\n```\n\nReturns an `EventSource` that fires **every time** the signal raises to (becomes greater than or equal after being less than) the value of `threshold`.\n\nThe emitted event (the argument passed to the callback function) has the value of `threshold`.\n\n**Note**: The initial value of the signal is assumed to be 0.0.\n\n**See Also**: `ReactiveModule.trigger`, `ReactiveModule.interval`."
           },
           {
              "name":"trigger",
              "description":"```\ntrigger(threshold: number): EventSource\n```\n\nReturns an `EventSource` that fires **the first time** the value of the signal raises (becomes greater than or equal) to the level of `threshold`. No more than one event is ever emitted by this `EventSource`.\n\nThe emitted event (the argument passed to the callback function) has the value of `threshold`.\n\n**Note**: for positive thresholds, `trigger` is equivalent to `interval(threshold).take(1)`.\n\n**See Also**: `ReactiveModule.multiTrigger`, `ReactiveModule.interval`."
           },
           {
              "name":"pinLastValue",
              "description":"```\npinLastValue(): ConstScalarSignal\n```\n\nReturns a `ConstScalarSignal` containing a constant value which is the last value of the specified signal before `pinLastValue` is called.\nConstScalarSignal can be passed to a functions which accept numbers."
           },
           {
              "name":"mod",
              "description":"```\nScalarSignal.mod(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ReactiveModule.mod`"
           },
           {
              "name":"le",
              "description":"```\nle(other: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **less than or equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.le`"
           },
           {
              "name":"delayBy",
              "description":"```\ndelayBy({milliseconds: number}): this\n```\nDelays a signal. The argument is an object with a \"milliseconds\" property specifying the delay duration in milliseconds."
           },
           {
              "name":"pin",
              "description":"```\npin(): ScalarSignal\n```\n\nReturns a `ScalarSignal` containing a constant value which is the value of the specified signal immediately after `pin` is called."
           },
           {
              "name":"ge",
              "description":"```\nge(other: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **greater than or equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.ge`"
           },
           {
              "name":"expSmooth",
              "description":"```\nexpSmooth(dampFactor: number): ScalarSignal\n```\n\nSmoothes a variable signal using exponential averaging over time. The argument specifies the dampening time constant in milliseconds.\n\n**Note**: See also `ReactiveModule.expSmooth`."
           },
           {
              "name":"toString",
              "description":"```\ntoString(): StringSignal\n```\n\nConverts a `ScalarSignal` to a `StringSignal` according to the default string formatting rules.\n\n**Note**: `ScalarSignal.format` allows more flexible control over the way the number is converted to string."
           },
           {
              "name":"cross",
              "description":"```\nVectorSignal.cross(other: VectorSignal): VectorSignal\n```\n\nReturns a vector signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"gt",
              "description":"```\ngt(other: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is strictly **greater than** the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.gt`"
           },
           {
              "name":"ne",
              "description":"```\nne(other: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **not equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**Note**: the scalar values are tested for exact equality. For some applications it might be reasonable to perform a non-strict comparison allowing the values to be within a small distance one from another.\n\n**See Also**: `ReactiveModule.ne`"
           },
           {
              "name":"schmittTrigger",
              "description":"```\nschmittTrigger(config: { low: number, high: number, initialValue: ?boolean}): BoolSignal\n```\n\nReturns a Boolean signal that is `true` when the input is strictly greater than the upper threshold, and `false` when it is strictly less than the lower threshold.\nFor input values between and including the thresholds, the Shmitt trigger returns the same value as at the previous update, or **initialValue** if this is the first update.\n\n**Note**: The initialValue is assumed to be `false` if it isn't specified."
           },
           {
              "name":"magnitude",
              "description":"```\nVectorSignal.magnitude(): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"interval",
              "description":"```\ninterval(threshold: number): EventSource\n```\n\nReturns an `EventSource` that emits an event whenever the supplied `ScalarSignal` first passes (becomes greater than or equal) a value of `N*threshold`, N = 1, 2, 3, ... Events are signaled in increasing order of N, starting from 1, with no omissions. For each value of N, the respective event is fired only once.\n\nThe emitted event (the argument passed to the callback function) has the value of corresponding `N*threshold`.\n\n**Note**: The threshold must be a positive number.\n\n**Note**: `interval` is mostly useful for non-negative non-decreasing scalar signals.\n\n**See Also**: `ReactiveModule.trigger`, `ReactiveModule.multiTrigger`."
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"eq",
              "description":"```\neq(other: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**Note**: the scalar values are tested for exact equality. For some applications it might be reasonable to perform a non-strict comparison allowing the values to be within a small distance one from another.\n\n**See Also**: `ReactiveModule.eq`"
           },
           {
              "name":"ceil",
              "description":"```\nScalarSignal.ceil(): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.ceil`"
           },
           {
              "name":"lt",
              "description":"```\nlt(other: ScalarSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is strictly **less than** the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.lt`"
           }
        ],
        "properties":[
           {
              "name":"lastValue",
              "description":"```\n(get) lastValue: number\n(set) (Not Available)\n```\n\nSpecifies a number that represents the last value of the signal.\n\n**Note**: The signal value is updated during simulation tick. This means that the value of `lastValue` is undefined before its first update. It is also undefined for signals that aren't used for any bindings/subscriptions, because those signals aren't guaranteed to be updated at each simulation tick."
           }
        ]
     },
     {
        "name":"SceneModule",
        "description":"The `SceneModule` class exposes properties and methods to access the objects in a scene.",
        "exampleCode":"// The following example demonstrates how to retrieve named elements from a Scene.\n\nconst Scene = require('Scene');\n\n// This example assumes the following scene tree in AR Studio:\n//\n// - Device (Default)\n//   - Camera (Default)\n//     - Focal Distance (Default)\n//       - plane3D (3D Plane)\n//         - planeText (2D Text)\n\n// A common practice is to parent most scene objects to the Focal Distance.\nconst fd = Scene.root.child('Device').child('Camera').child('Focal Distance');\n\n// 3D objects are addressed using the child() method:\nvar plane = fd.child('plane3D')\n\n// 2D objects are addressed using the planarChild() method:\nvar text = plane.planarChild('planeText2D');",
        "super":"Module",
        "methods":[
           {
              "name":"unprojectWithDepth",
              "description":"```\nunprojectWithDepth(location: PixelPointSignal, depth: number): PointSignal\n```\nReturns a signal with the value that corresponds to the 3d point value (in World Space, in current units) of the given screenSpace point from the PixelPointSignal\nThe z coordinate of the PointSignal will always be equal to the given depth value. The depth should be given in current units.\n\nThis function can be combined with TouchGestures to create a 3d point signal.\n```\nvar Scene = require('Scene')\nvar TouchGestures = require('TouchGestures')\nTouchGestures.onPan().subscribe(function(gesture) {\n  var signal = Scene.unprojectWithDepth(gesture.location, 0.5);\n});\n```"
           },
           {
              "name":"unprojectToFocalPlane",
              "description":"```\nunprojectToFocalPlane(location: PixelPointSignal): PointSignal\n```\n\nReturns a signal with the value that corresponds to the 3d point (in World Space, in current units) of the given screenSpace point from the PixelPointSignal.\nThe z coordinate of the PointSignal will be calculated so that the 3d point will always be on the canvas (which should be on the Focal Plane).\n\nThis function can be combined with TouchGestures to create a 3d point signal.\n```\nvar S = require('Scene')\nTouchGestures.onPan().subscribe(function(gesture) {\n  var signal = S.unprojectToFocalPlane(gesture.location);\n});\n```"
           }
        ],
        "properties":[
           {
              "name":"root",
              "description":"```\n(get) root: SceneObjectBase\n(set) (Not Available)\n```\n\nReturns an object that is the root of the scene tree. Other objects are accessed by walking down the scene tree from the root using the `SceneObjectBase.child` and `SceneObjectBase.find` methods."
           }
        ]
     },
     {
        "name":"PixelSizeSignal",
        "scope":"ReactiveModule",
        "description":"The `PixelSizeSignal` class monitors the pixel size of the camera info preview.",
        "methods":[

        ],
        "properties":[
           {
              "name":"height",
              "description":"```\n(get) height: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the height, in pixels."
           },
           {
              "name":"width",
              "description":"```\n(get) width: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the width, in pixels."
           }
        ]
     },
     {
        "name":"FocalPlane",
        "scope":"SceneModule",
        "description":"The `FocalPlane` class exposes details about the focal plane of the device camera.",
        "methods":[

        ],
        "properties":[
           {
              "name":"distance",
              "description":"```\n(get) distance: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the distance between focal plane and camera. Measured in 3D units."
           },
           {
              "name":"height",
              "description":"```\n(get) height: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the height of the focal plane. Measured in 3D units."
           },
           {
              "name":"width",
              "description":"```\n(get) width: ScalarSignal\n(set) (Not Available)\n```\n\nSpecifies the width of the focal plane. Measured in 3D units."
           }
        ]
     },
     {
        "name":"TextureTransform",
        "scope":"MaterialsModule",
        "description":"The `TextureTransform` class encapsulates scaling and translation transforms about a textures UV axis.",
        "methods":[

        ],
        "properties":[
           {
              "name":"scaleV",
              "description":"```\n(get) scaleV: ScalarSignal\n(set) scaleV: ScalarSignal\n```\n\nSpecifies the scale along the V-axis of the texture coordinates system."
           },
           {
              "name":"scaleU",
              "description":"```\n(get) scaleU: ScalarSignal\n(set) scaleU: ScalarSignal\n```\n\nSpecifies the scale along the U-axis of the texture coordinates system."
           },
           {
              "name":"rotation",
              "description":"```\n(get) rotation: ScalarSignal\n(set) rotation: ScalarSignal\n```\n\nSpecifies the rotation of the texture coordinates system in radians."
           },
           {
              "name":"offsetV",
              "description":"```\n(get) offsetV: ScalarSignal\n(set) offsetV: ScalarSignal\n```\n\nSpecifies the offset along the V-axis of the texture coordinates system."
           },
           {
              "name":"offsetU",
              "description":"```\n(get) offsetU: ScalarSignal\n(set) offsetU: ScalarSignal\n```\n\nSpecifies the offset along the U-axis of the texture coordinates system."
           }
        ]
     },
     {
        "name":"TimeDriver",
        "scope":"AnimationModule",
        "description":"The `TimeDriver` class controls an animation.",
        "super":"Driver",
        "methods":[
           {
              "name":"isRunning",
              "description":"```\nisRunning(): BoolSignal\n```\n\nReturns a `BoolSignal` indicating whether the animation is running."
           },
           {
              "name":"onAfterIteration",
              "description":"```\nonAfterIteration(): EventSource\n```\n\nReturns an `EventSource` to which you may subscribe. The event fires when the animation with loopCount completes an iteration.\nSubscribers will receive the one-based index of the completed iteration."
           },
           {
              "name":"onCompleted",
              "description":"```\nonCompleted(): EventSource\n```\n\nReturns an `EventSource` to which you may subscribe. The event fires once when the animation completes."
           },
           {
              "name":"reverse",
              "description":"```\nreverse(): void\n```\n\nReverses the animation from the moment it is called and goes back in time."
           },
           {
              "name":"reset",
              "description":"```\nreset(): void\n```\n\nResets the driver progress to time point zero."
           },
           {
              "name":"stop",
              "description":"```\nstop(): void\n```\n\nStops or pauses the animation."
           },
           {
              "name":"start",
              "description":"```\nstart(): void\n```\n\nStarts the animation."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"SourceImageRegionTexture",
        "scope":"TexturesModule",
        "description":"The `SourceImageRegionTexture` class.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"Point2D",
        "scope":"ReactiveModule",
        "description":"The `Point2D` class contains a 2D coordinate.",
        "methods":[

        ],
        "properties":[
           {
              "name":"y",
              "description":"```\n(get) y: number\n(set) y: number\n```\n\nSpecifies the vertical coordinate."
           },
           {
              "name":"x",
              "description":"```\n(get) x: number\n(set) x: number\n```\n\nSpecifies the horizontal coordinate."
           }
        ]
     },
     {
        "name":"Canvas",
        "scope":"SceneModule",
        "description":"The `Canvas` class describes a scene canvas.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"useSafeAreaMargins",
              "description":"```\n(get) useSafeAreaMargins: BoolSignal\n(set) useSafeAreaMargins: BoolSignal\n```\n\nSpecifies if Canvas should automatically include SafeArea margin to its content.\n**Note:** this is only effective when `renderMode` property is set to SCREEN_SPACE."
           },
           {
              "name":"bounds",
              "description":"```\n(get) bounds: Bounds2D\n(set) (Not Available)\n```\n\nRepresents the current 2D bounds relative to the parent element. This is the result of the layout calculation. Values are measured in 3D units.\n\n**Note**: The `Canvas.transform` property doesn't affect the layout, the transformation it specifies is applied on top of it."
           },
           {
              "name":"height",
              "description":"```\n(get) height: ScalarSignal\n(set) height: ScalarSignal\n```\n\nSpecifies the vertical size, in 3D units.\n**Note:** this is only effective when `renderMode` property is set to WORLD_SPACE."
           },
           {
              "name":"width",
              "description":"```\n(get) width: ScalarSignal\n(set) width: ScalarSignal\n```\n\nSpecifies the horizontal size, in 3D units.\n**Note:** this is only effective when `renderMode` property is set to WORLD_SPACE."
           },
           {
              "name":"renderMode",
              "description":"```\n(get) renderMode: SceneModule.RenderMode\n(set) renderMode: SceneModule.RenderMode\n```\n\nSpecifies how Canvas should be rendered.\nIn SCREEN_SPACE mode, Canvas is automatically placed and sized to fit the screen, `width` and `height` properties are ignored. `transform` property is still used, it is applied on top of the focal plane transform.\nIn WORLD_SPACE Canvas behaves as regular 3D object and is sized according to `width` and `height` properties."
           }
        ]
     },
     {
        "name":"EventSource",
        "scope":"ReactiveModule",
        "description":"The `EventSource` class provides methods for monitoring signals.",
        "super":"ISignal",
        "methods":[
           {
              "name":"take",
              "description":"```\ntake(count: number): EventSource\n```\n\nYields a filtered event source: the first `count` events from the original source are signaled, and subsequent ones ignored."
           },
           {
              "name":"select",
              "description":"```\nselect(property: string): EventSource\n```\n\nConverts event source by selecting a property in the event object. Events without specified property are ignored."
           },
           {
              "name":"skip",
              "description":"```\nskip(count: number): EventSource\n```\n\nYields a filtered event source: the first `count` events from the original source are dropped, and subsequent ones signaled."
           },
           {
              "name":"subscribeOnNext",
              "description":"```\nsubscribeOnNext(callback: (event: mixed) => void): Subscription\n```\n\nSets a callback for the event source. The callback will be invoked every time an event is emitted from this `EventSource`.\n\n**See Also**: `Subscription.unsubscribe`.\n\n**Note**: `subscribe` and `subscribeOnNext` functions are completely equivalent."
           },
           {
              "name":"subscribeWithSnapshot",
              "description":"```\nsubscribeWithSnapshot(snapshot: { [string]: Signal}, callback: (event: mixed, snapshot: mixed) => void): Subscription\n```\n\nSets a callback for the event source, similar to `Subscribe` function, but with additional `Snapshot` parameter.\n`Snapshot` is a dictionary of String/Bool/Scalar signals, which will be passed as JSON to the callback function using lastValue from requested signals"
           },
           {
              "name":"subscribe",
              "description":"```\nsubscribe(callback: (event: mixed) => void): Subscription\n```\n\nSets a callback for the event source. The callback will be invoked every time an event is emitted from this `EventSource`.\n\n**See Also**: `Subscription.unsubscribe`.\n\n**Note**: `subscribe` and `subscribeOnNext` functions are completely equivalent."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"BoolSignal",
        "scope":"ReactiveModule",
        "description":"The `BoolSignal` class monitors a boolean value.",
        "super":"ISignal",
        "methods":[
           {
              "name":"delayBy",
              "description":"```\ndelayBy({milliseconds: number}): this\n```\nDelays a signal. The argument is an object with a \"milliseconds\" property specifying the delay duration in milliseconds."
           },
           {
              "name":"ifThenElse",
              "description":"```\nifThenElse(thenValue: EventSource, elseValue: EventSource): EventSource\nifThenElse(thenValue: ScalarSignal, elseValue: ScalarSignal): ScalarSignal\nifThenElse(thenValue: StringSignal, elseValue: StringSignal): StringSignal\nifThenElse(thenValue: BoolSignal, elseValue: BoolSignal): BoolSignal\n```\n\nReturns a signal or an `EventSource` which at any point of time takes the value (passes the events in case of `EventSource`) of one or another inputs, depending on the momentary value of the given `BoolSignal`."
           },
           {
              "name":"onOff",
              "description":"```\nonOff(): EventSource\nonOff(config: { fireOnInitialValue: ?boolean}): EventSource\n```\n\nReturns an `EventSource` that emits an event every time the value of the input signal changes to `false`. The event contains a JSON object with the old and new values in the format:\n\n```\n{ \"oldValue\": val, \"newValue\": val }\n```\n\n**Note**: By default, there is no event fired for the initial value of the signal if it's `false` straight away. If `config.fireOnInitialValue` is set to `true` then an event for initial signal value is also emitted. `oldValue` is unset for this initial event."
           },
           {
              "name":"onOn",
              "description":"```\nonOn(): EventSource\nonOn(config: { fireOnInitialValue: ?boolean}): EventSource\n```\n\nReturns an `EventSource` that emits an event every time the value of the input signal changes to `true`. The event contains a JSON object with the old and new values in the format:\n\n```\n{ \"oldValue\": val, \"newValue\": val }\n```\n\n**Note**: By default, there is no event fired for the initial value of the signal if it's `true` straight away. If `config.fireOnInitialValue` is set to `true` then an event for initial signal value is also emitted. `oldValue` is unset for this initial event."
           },
           {
              "name":"pinLastValue",
              "description":"```\npinLastValue(): ConstBoolSignal\n```\n\nReturns a `ConstBoolSignal` containing a constant value which is the last value of the specified signal before `pinLastValue` is called.\nConstBoolSignal can be passed to a functions which accept bool."
           },
           {
              "name":"and",
              "description":"```\nand(other: BoolSignal): BoolSignal\n```\n\nReturns a signal with the value that is the logical conjunction of the values of the given signals. It is `true` every time both input signals are `true` and `false` at all other times.\n\n**See Also**: `ReactiveModule.and`"
           },
           {
              "name":"monitor",
              "description":"```\nmonitor(): EventSource\nmonitor(config: { fireOnInitialValue: ?boolean}): EventSource\n```\n\nReturns an `EventSource` that emits an event every time the value of the input signal changes. The event contains a JSON object with the old and new values in the format:\n\n```\n{ \"oldValue\": val, \"newValue\": val }\n```\n\n**Note**: By default, there is no event fired for the initial value of the signal. If `config.fireOnInitialValue` is set to `true` then an event for initial signal value is also emitted. `oldValue` is unset for this initial event."
           },
           {
              "name":"ne",
              "description":"```\nne(other: BoolSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **not equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.ne`"
           },
           {
              "name":"pin",
              "description":"```\npin(): BoolSignal\n```\n\nReturns a `BoolSignal` containing a constant value which is the value of the specified signal immediately after `pin` is called."
           },
           {
              "name":"xor",
              "description":"```\nxor(other: BoolSignal): BoolSignal\n```\n\nReturns a signal with the value that is the logical exclusive disjunction of the values of the given signals. It is `true` every time exactly one of the input signals is `true` and `false` at all other times.\n\n**Note**: It is equivalent to `BoolSignal.ne`.\n\n**See Also**: `ReactiveModule.xor`"
           },
           {
              "name":"not",
              "description":"```\nnot(): BoolSignal\n```\n\nReturns a signal with the logically negated value of the given signal.\n\n**See Also**: `ReactiveModule.not`"
           },
           {
              "name":"or",
              "description":"```\nor(other: BoolSignal): BoolSignal\n```\n\nReturns a signal with the value that is the logical disjunction of the values of the given signals. It is `true` every time at least one of the input signals is `true` and `false` at all other times.\n\n**See Also**: `ReactiveModule.or`"
           },
           {
              "name":"eq",
              "description":"```\neq(other: BoolSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.eq`"
           }
        ],
        "properties":[
           {
              "name":"lastValue",
              "description":"```\n(get) lastValue: boolean\n(set) (Not Available)\n```\n\nSpecifies a Boolean representing the last value of the signal.\n\n**Note**: The signal value is updated during simulation tick. This means that the value of `lastValue` is undefined before its first update. It is also undefined for signals that aren't used for any bindings/subscriptions, because those signals aren't guaranteed to be updated at each simulation tick."
           }
        ]
     },
     {
        "name":"BoundingBoxSignal",
        "scope":"ReactiveModule",
        "description":"The `BoundingBoxSignal` class monitors bounding box values.",
        "super":"ISignal",
        "methods":[

        ],
        "properties":[
           {
              "name":"center",
              "description":"```\n(get) x: Point2DSignal\n(set) (Not Available)\n```\n\nRepresents the center of the bounding box, in normalized screen space units."
           },
           {
              "name":"height",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the height of the bounding box, in normalized screen space units."
           },
           {
              "name":"width",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the width of the bounding box, in normalized screen space units."
           },
           {
              "name":"y",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Y-position of top left corner of the bounding box, in normalized screen space units."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the X-position of top left corner of the bounding box, in normalized screen space units."
           }
        ]
     },
     {
        "name":"SegmentationTexture",
        "scope":"TexturesModule",
        "description":"The `SegmentationTexture` class encapsulates a texture that will be used for image segmentation.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"DiagnosticsModule",
        "description":"The `DiagnosticsModule` class enables diagnostic logging.",
        "exampleCode":"const Diagnostics = require('Diagnostics');\nconst FaceTracking = require('FaceTracking');\n\nDiagnostics.log('Printing to the console');\n\nDiagnostics.log('Printing to the console');\nDiagnostics.watch('Number of faces detected ', FaceTracking.count);",
        "super":"Module",
        "methods":[
           {
              "name":"getTypeDescriptions",
              "description":"```\n  getTypeDescriptions(): Array<string>\n  ```\n\n  Finds the descriptions for each type in the effect."
           },
           {
              "name":"getModuleNames",
              "description":"```\n  getModuleNames(): Array<string>)\n  ```\n\n  Finds the names of all modules that can be loaded through `require` calls."
           },
           {
              "name":"watch",
              "description":"```\n  watch(tag: String, signal:BoolSignal): void\n  watch(tag: String, signal:ScalarSignal): void\n  watch(tag: String, signal:StringSignal): void\n  ```\n\n  Adds the specified signal to the watch view in AR Studio with the specified tag."
           },
           {
              "name":"log",
              "description":"```\n  log(content: Object): void\n  ```\n\n  Flattens content to a string and prints it to the debug console.\n  Note: this function can be reassigned to any var (i.e. `foo.log = Diagnostics.log;`)"
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"Point4DSignal",
        "scope":"ReactiveModule",
        "description":"The `Point4DSignal` class monitors a 4D coordinate.",
        "super":"ISignal",
        "methods":[
           {
              "name":"cross",
              "description":"```\nVectorSignal.cross(other: VectorSignal): VectorSignal\n```\n\nReturns a vector signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"round",
              "description":"```\nScalarSignal.round(): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ReactiveModule.round`"
           },
           {
              "name":"floor",
              "description":"```\nScalarSignal.floor(): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.floor`"
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"dot",
              "description":"```\nVectorSignal.dot(other: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"magnitude",
              "description":"```\nVectorSignal.magnitude(): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"atan2",
              "description":"```\nScalarSignal.atan2(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ReactiveModule.atan2`"
           },
           {
              "name":"mod",
              "description":"```\nScalarSignal.mod(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ReactiveModule.mod`"
           },
           {
              "name":"sub",
              "description":"```\nScalarSignal.sub(other: ScalarSignal): ScalarSignal\nPointSignal.sub(other: PointSignal): VectorSignal\nPointSignal.sub(other: VectorSignal): PointSignal\nVectorSignal.sub(other: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ReactiveModule.sub`, `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nScalarSignal.mul(other: ScalarSignal): ScalarSignal\nScalarSignal.mul(other: VectorSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ReactiveModule.mul`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"add",
              "description":"```\nScalarSignal.add(other: ScalarSignal): ScalarSignal\nPointSignal.add(other: VectorSignal): PointSignal\nVectorSignal.add(other: VectorSignal): VectorSignal\nVectorSignal.add(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"pow",
              "description":"```\nScalarSignal.pow(exponent: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\n\nRaising a negative base to the power of a fractional exponent produce a NaN.\nRaising 0 to the power of a negative exponent will produce positive infinity.\nRaising 0 to the power of any positive exponent will produce 0.\nRaising -1 to the power of a positive or negative infinity exponent will produce 1.\nRaising 1 to the power of any exponent, including NaN, will produce 1.\nRaising any base, including NaN, to the power of 0 will produce 1.\nRaising any base to the power of negative infinity, where |base| < 1, will produce positive infinity.\nRaising any base to the power of negative infinity, where |base| > 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| < 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| > 1, will produce positive infinity.\nRaising negative infinity to the power of a negative exponent will produce 0.\nRaising negative infinity to the power of a positive exponent will produce positive infinity.\nRaising positive infinity to the power of a negative exponent will produce 0.\nRaising positive infinity to the power of a positive exponent will produce positive infinity.\n\nIn all other cases, if either the base or the exponent is a NaN, a NaN will be produced.\n\n**See Also**: `ReactiveModule.pow`"
           },
           {
              "name":"sum",
              "description":"```\nScalarSignal.sum(other: ScalarSignal): ScalarSignal\nPointSignal.sum(other: VectorSignal): PointSignal\nVectorSignal.sum(other: VectorSignal): VectorSignal\nVectorSignal.sum(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"distance",
              "description":"```\nPointSignal.distance(other: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"sign",
              "description":"```\nScalarSignal.sign(): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ReactiveModule.sign`"
           },
           {
              "name":"div",
              "description":"```\nScalarSignal.div(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ReactiveModule.div`"
           },
           {
              "name":"sqrt",
              "description":"```\nScalarSignal.sqrt(): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ReactiveModule.sqrt`"
           },
           {
              "name":"neg",
              "description":"```\nScalarSignal.neg(): ScalarSignal\nVectorSignal.neg(): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ReactiveModule.neg`, `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"abs",
              "description":"```\nScalarSignal.abs(): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ReactiveModule.abs`"
           },
           {
              "name":"ceil",
              "description":"```\nScalarSignal.ceil(): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.ceil`"
           }
        ],
        "properties":[
           {
              "name":"w",
              "description":"```\n  (get) w: ScalarSignal\n  (set) (Not Available)\n  ```\n\n  Represents the W component."
           },
           {
              "name":"z",
              "description":"```\n  (get) z: ScalarSignal\n  (set) (Not Available)\n  ```\n\n  Represents the Z component."
           },
           {
              "name":"y",
              "description":"```\n  (get) y: ScalarSignal\n  (set) (Not Available)\n  ```\n\n  Represents the Y coordinate."
           },
           {
              "name":"x",
              "description":"```\n  (get) x: ScalarSignal\n  (set) (Not Available)\n  ```\n\n  Represents the X coordinate."
           }
        ]
     },
     {
        "name":"StringSignal",
        "scope":"ReactiveModule",
        "description":"The `StringSignal` class monitors a string value.",
        "super":"ISignal",
        "methods":[
           {
              "name":"delayBy",
              "description":"```\ndelayBy({milliseconds: number}): this\n```\nDelays a signal. The argument is an object with a \"milliseconds\" property specifying the delay duration in milliseconds."
           },
           {
              "name":"pinLastValue",
              "description":"```\npinLastValue(): ConstStringSignal\n```\n\nReturns a `ConstStringSignal` containing a constant value which is the last value of the specified signal before `pinLastValue` is called.\nConstStringSignal can be passed to a functions which accept strings"
           },
           {
              "name":"monitor",
              "description":"```\nmonitor(): EventSource\nmonitor(config: { fireOnInitialValue: ?boolean}): EventSource\n```\n\nReturns an `EventSource` that emits an event every time the value of the input signal changes. The event contains a JSON object with the old and new values in the format:\n\n```\n{ \"oldValue\": val, \"newValue\": val }\n```\n\n**Note**: By default, there is no event fired for the initial value of the signal. If `config.fireOnInitialValue` is set to `true` then an event for initial signal value is also emitted. `oldValue` is unset for this initial event."
           },
           {
              "name":"ne",
              "description":"```\nne(other: StringSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **not equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.ne`"
           },
           {
              "name":"pin",
              "description":"```\npin(): StringSignal\n```\n\nReturns a `StringSignal` containing a constant value which is the value of the specified signal immediately after `pin` is called."
           },
           {
              "name":"concat",
              "description":"```\nconcat(other: StringSignal): StringSignal\n```\n\nReturns a `StringSignal` containing the concatenation of the values specified by the input signals.\n\n**See Also**: `ReactiveModule.concat`"
           },
           {
              "name":"eq",
              "description":"```\neq(other: StringSignal): BoolSignal\n```\n\nReturns a Boolean signal that takes the value of `true` every time when the value of the left-hand-side signal is **equal** to the value of the right-hand-side one, and the value of `false` all other time.\n\n**See Also**: `ReactiveModule.eq`"
           }
        ],
        "properties":[
           {
              "name":"lastValue",
              "description":"```\n(get) lastValue: string\n(set) (Not Available)\n```\n\nSpecifies a string that represents the last value of the signal.\n\n**Note**: The signal value is updated during simulation tick. This means that the value of `lastValue` is undefined before its first update. It is also undefined for signals that aren't used for any bindings/subscriptions, because those signals aren't guaranteed to be updated at each simulation tick."
           }
        ]
     },
     {
        "name":"ShaderSignal",
        "scope":"ReactiveModule",
        "description":"The `ShaderSignal` represents a shader signal.",
        "super":"ISignal",
        "methods":[
           {
              "name":"cross",
              "description":"```\nVectorSignal.cross(other: VectorSignal): VectorSignal\n```\n\nReturns a vector signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"round",
              "description":"```\nScalarSignal.round(): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ReactiveModule.round`"
           },
           {
              "name":"floor",
              "description":"```\nScalarSignal.floor(): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.floor`"
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"dot",
              "description":"```\nVectorSignal.dot(other: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"magnitude",
              "description":"```\nVectorSignal.magnitude(): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"atan2",
              "description":"```\nScalarSignal.atan2(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ReactiveModule.atan2`"
           },
           {
              "name":"mod",
              "description":"```\nScalarSignal.mod(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ReactiveModule.mod`"
           },
           {
              "name":"sub",
              "description":"```\nScalarSignal.sub(other: ScalarSignal): ScalarSignal\nPointSignal.sub(other: PointSignal): VectorSignal\nPointSignal.sub(other: VectorSignal): PointSignal\nVectorSignal.sub(other: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ReactiveModule.sub`, `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nScalarSignal.mul(other: ScalarSignal): ScalarSignal\nScalarSignal.mul(other: VectorSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ReactiveModule.mul`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"add",
              "description":"```\nScalarSignal.add(other: ScalarSignal): ScalarSignal\nPointSignal.add(other: VectorSignal): PointSignal\nVectorSignal.add(other: VectorSignal): VectorSignal\nVectorSignal.add(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"pow",
              "description":"```\nScalarSignal.pow(exponent: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\n\nRaising a negative base to the power of a fractional exponent produce a NaN.\nRaising 0 to the power of a negative exponent will produce positive infinity.\nRaising 0 to the power of any positive exponent will produce 0.\nRaising -1 to the power of a positive or negative infinity exponent will produce 1.\nRaising 1 to the power of any exponent, including NaN, will produce 1.\nRaising any base, including NaN, to the power of 0 will produce 1.\nRaising any base to the power of negative infinity, where |base| < 1, will produce positive infinity.\nRaising any base to the power of negative infinity, where |base| > 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| < 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| > 1, will produce positive infinity.\nRaising negative infinity to the power of a negative exponent will produce 0.\nRaising negative infinity to the power of a positive exponent will produce positive infinity.\nRaising positive infinity to the power of a negative exponent will produce 0.\nRaising positive infinity to the power of a positive exponent will produce positive infinity.\n\nIn all other cases, if either the base or the exponent is a NaN, a NaN will be produced.\n\n**See Also**: `ReactiveModule.pow`"
           },
           {
              "name":"sum",
              "description":"```\nScalarSignal.sum(other: ScalarSignal): ScalarSignal\nPointSignal.sum(other: VectorSignal): PointSignal\nVectorSignal.sum(other: VectorSignal): VectorSignal\nVectorSignal.sum(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"distance",
              "description":"```\nPointSignal.distance(other: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"sign",
              "description":"```\nScalarSignal.sign(): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ReactiveModule.sign`"
           },
           {
              "name":"div",
              "description":"```\nScalarSignal.div(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ReactiveModule.div`"
           },
           {
              "name":"sqrt",
              "description":"```\nScalarSignal.sqrt(): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ReactiveModule.sqrt`"
           },
           {
              "name":"neg",
              "description":"```\nScalarSignal.neg(): ScalarSignal\nVectorSignal.neg(): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ReactiveModule.neg`, `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"abs",
              "description":"```\nScalarSignal.abs(): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ReactiveModule.abs`"
           },
           {
              "name":"ceil",
              "description":"```\nScalarSignal.ceil(): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.ceil`"
           }
        ],
        "properties":[
           {
              "name":"w",
              "description":"Gets the W component."
           },
           {
              "name":"z",
              "description":"Gets the Z component."
           },
           {
              "name":"y",
              "description":"Gets the Y component."
           },
           {
              "name":"x",
              "description":"Gets the X component."
           }
        ]
     },
     {
        "name":"BoundingBox",
        "scope":"SceneModule",
        "description":"The `BoundingBox` class describes the bounds of a scene element in the local coordinate system.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"ParticleTypeDescription",
        "scope":"SceneModule",
        "description":"The `ParticleTypeDescription` class provides functionality for setting particle sprite densities in the scene.",
        "methods":[

        ],
        "properties":[
           {
              "name":"fraction",
              "description":"```\n(get) fraction: ScalarValue\n(set) fraction: ScalarSignal\n```\n\nThe fraction of particles, that should be of that ParticleTypeDescription. This is thought to be used for making the sorting better between different particles. The user can specify the fraction of particles that can use the specific frames of one sprite sheet (which is specified from the UI), which would make sorting of different particles proper."
           }
        ]
     },
     {
        "name":"BoolValue",
        "scope":"ReactiveModule",
        "description":"The `BoolValue` class contains a Boolean value.",
        "methods":[
           {
              "name":"pinLastValue",
              "description":"```\npinLastValue(): ConstBoolSignal\n```\n\nReturns a `ConstBoolSignal` containing a constant value which is the last value of the specified signal before `pinLastValue` is called.\nConstBoolSignal can be passed to a functions which accept bools."
           }
        ],
        "properties":[
           {
              "name":"lastValue",
              "description":"```\n(get) lastValue: boolean\n(set) (Not Available)\n```\n\nSpecifies a Boolean representing the last value of the object."
           }
        ]
     },
     {
        "name":"Module",
        "description":"The base class for all modules.",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"PlanarObject",
        "scope":"SceneModule",
        "description":"The `PlanarObject` class describes an object on a plane.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"bounds",
              "description":"```\n(get) bounds: Bounds2D\n(set) (Not Available)\n```\n\nRepresents the current 2D bounds relative to the parent element. This is the result of the layout calculation. Values are measured in 3D units.\n\n**Note**: The `SceneObjectBase.transform` property doesn't affect the layout, the transformation it specifies is applied on top of it."
           },
           {
              "name":"scalingOption",
              "description":"```\n(get) (Not Available)\n(set) scalingOption: SceneModule.ScalingOption\n```\n\nSpecifies the size adjustment relative to parent."
           },
           {
              "name":"verticalAlignment",
              "description":"```\n(get) (Not Available)\n(set) verticalAlignment: SceneModule.VerticalAlignment\n```\n\nSpecifies the vertical alignment."
           },
           {
              "name":"horizontalAlignment",
              "description":"```\n(get) (Not Available)\n(set) horizontalAlignment: SceneModule.HorizontalAlignment\n```\n\nSpecifies the horizontal alignment."
           },
           {
              "name":"yOffset",
              "description":"```\n(get) (Not Available)\n(set) yOffset: number\n```\n\nSpecifies the vertical offset of the object.\n\n**Note**: the specific measurement unit used depends on the context. It is usually regular 3D units unless the object is a descendant of a Screen Plane (2D Canvas) object when the unit might be interpreted in a special way.\n\n**Note**: this parameter is used as an input to the layout algorithm. The layout-calculated size and location of the object is available via `PlanarObject.bounds` property. The `SceneObjectBase.transform` property doesn't affect the layout, the transformation it specifies is applied on top of it."
           },
           {
              "name":"marginEnd",
              "description":"```\n(get) (Not Available)\n(set) marginEnd: number\n```\n\nSpecifies the size of the right margin.\n\n**Note**: it behaves in a similar way to the `margin-right` CSS property."
           },
           {
              "name":"xOffset",
              "description":"```\n(get) (Not Available)\n(set) xOffset: number\n```\n\nSpecifies the horizontal offset of the object.\n\n**Note**: the specific measurement unit used depends on the context. It is usually regular 3D units unless the object is a descendant of a Screen Plane (2D Canvas) object when the unit might be interpreted in a special way.\n\n**Note**: this parameter is used as an input to the layout algorithm. The layout-calculated size and location of the object is available via `PlanarObject.bounds` property. The `SceneObjectBase.transform` property doesn't affect the layout, the transformation it specifies is applied on top of it."
           },
           {
              "name":"marginTop",
              "description":"```\n(get) (Not Available)\n(set) marginTop: number\n```\n\nSpecifies the size of the top margin.\n\n**Note**: it behaves in a similar way to the `margin-top` CSS property."
           },
           {
              "name":"marginStart",
              "description":"```\n(get) (Not Available)\n(set) marginStart: number\n```\n\nSpecifies the size of the left margin.\n\n**Note**: it behaves in a similar way to the `margin-left` CSS property."
           },
           {
              "name":"height",
              "description":"```\n(get) (Not Available)\n(set) height: number\n```\n\nSpecifies the height of the object.\n\n**Note**: the specific measurement unit used depends on the context. It is usually regular 3D units unless the object is a descendant of a Screen Plane (2D Canvas) object when the unit might be interpreted in a special way.\n\n**Note**: this parameter is used as an input to the layout algorithm. The layout-calculated size and location of the object is available via `PlanarObject.bounds` property. The `SceneObjectBase.transform` property doesn't affect the layout, the transformation it specifies is applied on top of it."
           },
           {
              "name":"marginBottom",
              "description":"```\n(get) (Not Available)\n(set) marginBottom: number\n```\n\nSpecifies the size of the bottom margin.\n\n**Note**: it behaves in a similar way to the `margin-bottom` CSS property."
           },
           {
              "name":"width",
              "description":"```\n(get) (Not Available)\n(set) width: number\n```\n\nSpecifies the width of the object.\n\n**Note**: the specific measurement unit used depends on the context. It is usually regular 3D units unless the object is a descendant of a Screen Plane (2D Canvas) object when the unit might be interpreted in a special way.\n\n**Note**: this parameter is used as an input to the layout algorithm. The layout-calculated size and location of the object is available via `PlanarObject.bounds` property. The `SceneObjectBase.transform` property doesn't affect the layout, the transformation it specifies is applied on top of it."
           }
        ]
     },
     {
        "name":"RandomModule",
        "description":"The `RandomModule` class enables random number generation.",
        "super":"Module",
        "methods":[
           {
              "name":"random"
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"SceneObject",
        "scope":"SceneModule",
        "description":"The `SceneObject` class describes an object in a scene.",
        "super":"SceneObjectBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"BlendShapeImageWarpMaterial",
        "scope":"MaterialsModule",
        "description":"The `BlendShapeImageWarpMaterial` class.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[

        ]
     },
     {
        "name":"TexturesModule",
        "description":"The `TexturesModule` class enables images, animation sequences, videos, colors, and other visual artifacts to be combined to form materials.",
        "exampleCode":"const Textures = require('Textures');\nconst Materials = require('Materials');\n\nconst material = Materials.get('textureMaterial');\nmaterial.diffuse = Textures.get('texture');",
        "super":"Module",
        "methods":[
           {
              "name":"get",
              "description":"```\nget(textureName: string): TextureBase\n```\n\nReturns a texture object, derived from `TextureBase`, that is specified by `textureName`. An exception is thrown when the texture isn't found in the project. Possible types are:\n\n  * `CanvasTexture`\n  * `ColorTexture`\n  * `DeepLinkTexture`\n  * `ExternalTexture`\n  * `ImageTexture`\n  * `SequenceTexture`\n\n**See Also**: `TextureBase.name`."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"BlendShape",
        "scope":"SceneModule",
        "description":"The `BlendShape` class describes a face which can be blended.",
        "methods":[

        ],
        "properties":[
           {
              "name":"name",
              "description":"```\n  (get) name: String\n  (set) (Not Available)\n  ```\n\n  Retrieves the name of the BlendShape."
           },
           {
              "name":"prefabName",
              "description":"```\n(get) prefabName: String\n(set) (Not Available)\n```\n\nSpecifies the name of prefab for BlendShape. This is the unique identifier of the prefab."
           },
           {
              "name":"weight",
              "description":"```\n                  (get) weight: ScalarValue\n                  (set) weight: ScalarSignal\n                  ```\n\n                  Specifies the weight of the blend shape."
           }
        ]
     },
     {
        "name":"CameraVisibility",
        "scope":"SceneModule",
        "description":"The `CameraVisibility` class describes whether or not an object is visible from various camera views.",
        "methods":[

        ],
        "properties":[
           {
              "name":"forBackCamera",
              "description":"```\n(get) forBackCamera: BoolValue\n(set) forBackCamera: BoolSignal\n```\n\nSpecifies whether the object is visible when the back camera is the active one."
           },
           {
              "name":"forFrontCamera",
              "description":"```\n(get) forFrontCamera: BoolValue\n(set) forFrontCamera: BoolSignal\n```\n\nSpecifies whether the object is visible when the front camera is the active one."
           },
           {
              "name":"forUnspecifiedCamera",
              "description":"```\n(get) forUnspecifiedCamera: BoolValue\n(set) forUnspecifiedCamera: BoolSignal\n```\n\nSpecifies whether the object is visible when the active camera couldn't be specified."
           }
        ]
     },
     {
        "name":"WorldTransform",
        "scope":"SceneModule",
        "description":"The `WorldTransform` class describes an object tranform for a sceneObject in world space.",
        "methods":[
           {
              "name":"applyTo",
              "description":"```\napplyTo(transform: TransformSignal): TransformSignal\napplyTo(point: PointSignal): PointSignal\napplyTo(vector: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is equal to the value of the provided transformation/point/vector with the transformation of the current `TransformSignal` applied to it."
           },
           {
              "name":"inverse",
              "description":"```\ninverse(): TransformSignal\n```\n\nReturns a signal with the value that is equal to the inverted transformation value of the given signal at any point of time."
           },
           {
              "name":"toSignal",
              "description":"```\ntoSignal(): TransformSignal\n```\n\nReturns a signal for a given transformation."
           }
        ],
        "properties":[
           {
              "name":"scaleZ",
              "description":"```\n(get) scaleZ: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents scale along the Z-axis of the world coordinate system."
           },
           {
              "name":"scaleY",
              "description":"```\n(get) scaleY: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents scale along the Y-axis of the world coordinate system."
           },
           {
              "name":"rotationZ",
              "description":"```\n(get) rotationZ: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents rotation about the Z-axis of the world coordinate system, in radians. The signal value is in the range [-PI, PI].\n\n**Note**: The order of operations (rotations in particular) is the same as in `Transform`. The rotations are applied to the object in Z-Y-X order. The Z rotation is applied last to the object, therefore if the `rotationX` or `rotationY` is not zero, then `rotationZ` is applied not in the object's local coordinate system but in the rotated one."
           },
           {
              "name":"rotationY",
              "description":"```\n(get) rotationY: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents rotation about the Y-axis of the world coordinate system, in radians. The signal value is in the range [-PI, PI].\n\n**Note**: The order of operations (rotations in particular) is the same as in `Transform`. The rotations are applied to the object in Z-Y-X order. The Y rotation is applied second to the object, therefore if the `rotationX` is not zero, then `rotationY` is applied not in the object's local coordinate system but in the rotated one."
           },
           {
              "name":"z",
              "description":"```\n(get) z: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the offset along the Z-axis of the world coordinate system."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the offset along the Y-axis of the world coordinate system."
           },
           {
              "name":"scaleX",
              "description":"```\n(get) scaleX: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents scale along the X-axis of the world coordinate system."
           },
           {
              "name":"rotationX",
              "description":"```\n(get) rotationX: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents rotation about the X-axis of the world coordinate system, in radians. The signal value is in the range [-PI, PI].\n\n**Note**: The order of operations (rotations in particular) is the same as in `Transform`. The rotations are applied to the object in Z-Y-X order. The X rotation is applied first to the object."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the offset along the X-axis of the world coordinate system."
           },
           {
              "name":"scale",
              "description":"```\n(get) scale: ScaleSignal\n(set) (Not Available)\n```\n\nRepresents scale in the world coordinate system."
           },
           {
              "name":"position",
              "description":"```\n(get) position: PointSignal\n(set) position: PointSignal\n```\n\nSpecifies the object position along the X, Y and Z axis of the world coordinate system."
           }
        ]
     },
     {
        "name":"Transform",
        "scope":"SceneModule",
        "description":"The `Transform` class describes an object transform for a scene.",
        "methods":[
           {
              "name":"toSignal",
              "description":"```\ntoSignal(): TransformSignal\n```\n\nReturns a signal for a given transformation."
           }
        ],
        "properties":[
           {
              "name":"scaleZ",
              "description":"```\n(get) scaleZ: ScalarSignal\n(set) scaleZ: ScalarSignal\n```\n\nSpecifies the object scale along the Z-axis of the object's local coordinate system."
           },
           {
              "name":"rotation",
              "description":"```\n(get) (Not Available)\n(set) rotation: Rotation\n```\n\nSpecifies the object rotation along the X, Y and Z axis of the object's local coordinate system."
           },
           {
              "name":"position",
              "description":"```\n(get) position: PointSignal\n(set) position: PointSignal\n```\n\nSpecifies the object position along the X, Y and Z axis of the object's local coordinate system."
           },
           {
              "name":"scale",
              "description":"```\n(set) scale: ScaleSignal\n(set) scale: ScaleSignal\n```\n\nSpecifies the object scale along the X, Y and Z axis."
           },
           {
              "name":"rotationZ",
              "description":"```\n(get) rotationZ: ScalarSignal\n(set) rotationZ: ScalarSignal\n```\n\nSpecifies the object rotation about the Z-axis of the object's rotated local coordinate system, in radians.\n\n**Note**: the rotations are applied to the object in Z-Y-X order. The Z rotation is applied last to the object, therefore if the `rotationX` or `rotationY` is not zero, then `rotationZ` is applied not in the object's local coordinate system but in the rotated one."
           },
           {
              "name":"rotationY",
              "description":"```\n(get) rotationY: ScalarSignal\n(set) rotationY: ScalarSignal\n```\n\nSpecifies the object rotation about the Y-axis of the object's rotated local coordinate system, in radians.\n\n**Note**: the rotations are applied to the object in Z-Y-X order. The Y rotation is applied second to the object, therefore if the `rotationX` is not zero, then `rotationY` is applied not in the object's local coordinate system but in the rotated one."
           },
           {
              "name":"scaleY",
              "description":"```\n(get) scaleY: ScalarSignal\n(set) scaleY: ScalarSignal\n```\n\nSpecifies the object scale along the Y-axis of the object's local coordinate system."
           },
           {
              "name":"rotationX",
              "description":"```\n(get) rotationX: ScalarSignal\n(set) rotationX: ScalarSignal\n```\n\nSpecifies the object rotation about the X-axis of the object's local coordinate system, in radians.\n\n**Note**: the rotations are applied to the object in Z-Y-X order. The X rotation is applied first to the object, therefore it is always performed in the object's local coordinate system."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) x: ScalarSignal\n```\n\nSpecifies the object offset along the X-axis of the object's local coordinate system."
           },
           {
              "name":"scaleX",
              "description":"```\n(get) scaleX: ScalarSignal\n(set) scaleX: ScalarSignal\n```\n\nSpecifies the object scale along the X-axis of the object's local coordinate system."
           },
           {
              "name":"z",
              "description":"```\n(get) z: ScalarSignal\n(set) z: ScalarSignal\n```\n\nSpecifies the object offset along the Z-axis of the object's local coordinate system."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) y: ScalarSignal\n```\n\nSpecifies the object offset along the Y-axis of the object's local coordinate system."
           }
        ]
     },
     {
        "name":"SceneObjectBase",
        "scope":"SceneModule",
        "description":"The `SceneObjectBase` class describes a scene object.",
        "methods":[
           {
              "name":"find",
              "description":"```\nfind(name: string): SceneObjectBase\n```\n\nReturns a descendant object by name. An exception is thrown if the object isn't found or if more than one is found.\n\n**Note**: object D is considered to be a descendant of object P if either D is a child of P or if such an object C which is a child of P exists that D is a descendant of C.\n\n**See Also**: `SceneObjectBase.child`, `SceneModule.root`."
           },
           {
              "name":"child",
              "description":"```\nchild(name: string): SceneObjectBase\n```\n\nReturns a child object by name. An exception is thrown if the object isn't found.\n\n**See Also**: `SceneObjectBase.find`, `SceneModule.root`."
           }
        ],
        "properties":[
           {
              "name":"parentWorldTransform",
              "description":"```\n(get) parentWorldTransform: TransformSignal\n(set) (Not Available)\n```\n\nSpecifies a `TransformSignal` object describing the parent's transformation relative to world coordinate system."
           },
           {
              "name":"outputVisibility",
              "description":"```\n(get) outputVisibility: OutputVisibility\n(set) (Not Available)\n```\n\nRepresents the `OutputVisibility` that contains a set of flags that specify the scene object (and its descendants) visibility depending on the output."
           },
           {
              "name":"cameraVisibility",
              "description":"```\n(get) cameraVisibility: CameraVisibility\n(set) (Not Available)\n```\n\nRepresents the `CameraVisibility` that contains a set of flags that specify the scene object (and its descendants) visibility depending on the active camera."
           },
           {
              "name":"worldTransform",
              "description":"```\n(get) worldTransform: WorldTransform\n(set) worldTransform: TransformSignal\n```\n\nSpecifies a `TransformSignal` object describing the object's transformation relative to world coordinate system.\nWorld transform in not yet supported for Canvas and Legacy canvas. Accessing this property from such objects or any of their children is not allowed."
           },
           {
              "name":"hidden",
              "description":"```\n(get) hidden: BoolSignal\n(set) hidden: BoolSignal\n```\n\nSpecifies whether the scene object and its descendants are hidden."
           },
           {
              "name":"materialIdentifier",
              "description":"```\n(get) materialIdentifier: String\n(set) (Not Available)\n```\n\nSpecifies the unique material identifier assigned to scene object. This value is specified internally in AR Studio."
           },
           {
              "name":"transform",
              "description":"```\n(get) transform: Transform\n(set) transform: TransformSignal\n```\n\nRepresents the object transformation, in object's local coordinate system."
           },
           {
              "name":"identifier",
              "description":"```\n(get) identifier: String\n(set) (Not Available)\n```\n\nSpecifies the scene object unique identifier. This value is specified internally in AR Studio."
           },
           {
              "name":"boundingBoxVisible",
              "description":"```\n(get) boundingBoxVisible: BoolSignal\n(set) (Not Available)\n```\n\nRepresents whether or not the bounding box for the object is visible."
           },
           {
              "name":"name",
              "description":"```\n(get) name: String\n(set) (Not Available)\n```\n\nSpecifies the scene object name. This is the unique identifier of the object within the list of its siblings (immediate child objects of the same parent object).\n\n**Note**: the object name is specified in AR Studio UI during design time.\n\n**Note**: the object name must only be unique withing the list of direct siblings. There can be more than object with the same name in the scene as soon as they have different parents.\n\n**See Also**: `SceneObjectBase.child`, `SceneObjectBase.find`, `SceneModule.root`."
           }
        ]
     },
     {
        "name":"CustomMaterial",
        "scope":"MaterialsModule",
        "description":"The `CustomMaterial` class describes a custom material shader.",
        "super":"MaterialBase",
        "methods":[
           {
              "name":"setBoolParameter",
              "description":"```\nsetBoolParameter(paramName: string, source: BoolSignal): void\n```\n\nSpecifies the value of a shader parameter indicated by the `paramName` argument. An exception is thrown when the identifier isn't found in the material.\n\n**See Also**: `CustomMaterial.boolParameter`."
           },
           {
              "name":"boolParameter",
              "description":"```\nboolParameter(paramName: string): BoolValue\n```\n\nReturns the Boolean value indicated by the `paramName` argument. An exception is thrown when the identifier isn't found in the material.\n\n**See Also**: `CustomMaterial.setBoolParameter`."
           },
           {
              "name":"setTexture",
              "description":"```\nsetTexture(paramName: string, texture: TextureBase): void\n```\n\nSpecifies the value of the shader parameter indicated by the `paramName` argument. An exception is thrown when the identifier isn't found in the material."
           },
           {
              "name":"setFloatParameter",
              "description":"```\nsetFloatParameter(paramName: string, source: ScalarSignal): void\n```\n\nSpecifies the value of the shader parameter indicated by the `paramName` argument. An exception is thrown when the identifier isn't found in the material.\n\n**See Also**: `CustomMaterial.floatParameter`."
           },
           {
              "name":"floatParameter",
              "description":"```\nfloatParameter(paramName: string): ScalarValue\n```\n\nReturns the `ScalarValue` value representing the shader parameter indicated by the `paramName` argument. An exception is thrown when the identifier isn't found in the material.\n\n**See Also**: `CustomMaterial.setFloatParameter`."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"InsetsSignal",
        "scope":"ReactiveModule",
        "description":"The `InsetsSignal` class monitors the insets of the effect safe area.",
        "methods":[

        ],
        "properties":[
           {
              "name":"right",
              "description":"```\n(get) right: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the right component of the Insets."
           },
           {
              "name":"bottom",
              "description":"```\n(get) bottom: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the bottom component of the Insets."
           },
           {
              "name":"left",
              "description":"```\n(get) left: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the left component of the Insets."
           },
           {
              "name":"top",
              "description":"```\n(get) top: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the top component of the Insets."
           }
        ]
     },
     {
        "name":"MaterialBase",
        "scope":"MaterialsModule",
        "description":"The `MaterialBase` class exposes properties common to all material types.",
        "methods":[
           {
              "name":"setTexture"
           }
        ],
        "properties":[
           {
              "name":"alphaCutoff",
              "description":"```\n(get) alphaCutoff: ScalarSignal\n(set) alphaCutoff: ScalarSignal\n```\nSpecifies a number between 0.0 and 1.0."
           },
           {
              "name":"opacity",
              "description":"```\n(get) opacity: ScalarSignal\n(set) opacity: ScalarSignal\n```\n\nSpecifies a number between 0.0 and 1.0 indicating the opacity threshold for discarding pixels. 0 is transparent and 1 is opaque."
           },
           {
              "name":"identifier",
              "description":"```\n(get) identifier: String\n(set) (Not Available)\n```\n\nSpecifies the unique identifier for the material."
           },
           {
              "name":"diffuseTextureTransform",
              "description":"```\n(get) transform: TextureTransform\n(set) transform: TextureTransformSignal\n```\n\nSpecifies the coordinates transform of the diffuse texture of this material."
           },
           {
              "name":"diffuse",
              "description":"```\n(get) diffuse: TextureBase\n(set) diffuse: TextureBase\n```\n\nSpecifies the texture that forms the basis of this material."
           },
           {
              "name":"doubleSided",
              "description":"```\n(get) doubleSided: BoolSignal\n(set) doubleSided: BoolSignal\n```\n\nIndicates whether the material can be seen from both sides when rendering the scene.\n\n**Note**: When `FALSE`, only the side specified by object's **Cull Mode** is rendered."
           },
           {
              "name":"__internalDiffuseTextureIdentifier",
              "description":"```\n(get) __internalDiffuseTextureIdentifier: String\n(set) (Not Available)\n```\n\nSpecifies the unique internal diffuse identifier for the texture, assigned to material."
           },
           {
              "name":"name",
              "description":"```\n(get) name: String\n(set) (Not Available)\n```\n\nSpecifies the unique identifier for the material name. This value is specified in AR Studio at design time.\n\n**See Also**: `MaterialsModule.get`."
           }
        ]
     },
     {
        "name":"Scene",
        "scope":"SceneModule",
        "description":"The `Scene` class implements properties and methods to access the objects in a scene.",
        "methods":[
           {
              "name":"find",
              "description":"```\nfind(name: string): SceneObjectBase\n```\n\nReturns a descendant object by name. An exception is thrown if the object isn't found or if more than one is found.\n\n**Note**: object D is considered to be a descendant of object P if either D is a child of P or if such an object C which is a child of P exists that D is a descendant of C.\n\n**See Also**: `SceneObjectBase.child`, `SceneModule.root`."
           },
           {
              "name":"child",
              "description":"```\nchild(name: string): SceneObjectBase\n```\n\nReturns a child object by name. An exception is thrown if the object isn't found.\n\n**See Also**: `SceneObjectBase.find`, `SceneModule.root`."
           }
        ],
        "properties":[

        ]
     },
     {
        "name":"SubTexture",
        "scope":"TexturesModule",
        "description":"The `SubTexture` class exposes details of a texture in UV coordinates.",
        "super":"TextureBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"sizeV",
              "description":"```\n(get) sizeV: ScalarSignal\n(set) sizeV: ScalarSignal\n```\n\nSpecifies the vertical span in UV texture coordinates."
           },
           {
              "name":"sizeU",
              "description":"```\n(get) sizeU: ScalarSignal\n(set) sizeU: ScalarSignal\n```\n\nSpecifies the horizontal span in UV texture coordinates."
           },
           {
              "name":"minV",
              "description":"```\n(get) minV: ScalarSignal\n(set) minV: ScalarSignal\n```\n\nSpecifies the position of the bottom boundary in UV texture coordinates."
           },
           {
              "name":"minU",
              "description":"```\n(get) minU: ScalarSignal\n(set) minU: ScalarSignal\n```\n\nSpecifies the position of the left boundary in UV texture coordinates."
           }
        ]
     },
     {
        "name":"CameraInfoModule",
        "description":"The `CameraInfoModule` class provides access to details about the device camera.",
        "exampleCode":"// The following example demonstrates how to monitor the camera for a change in the recording state.\n\nconst Reactive = require('Reactive');\nconst Scene = require('Scene');\nconst CameraInfo = require('CameraInfo');\n\nconst hideUi = Reactive.or(CameraInfo.isRecordingVideo, CameraInfo.isCapturingPhoto);\nconst onScreenInstructions = Scene.root.find('canvas0');\n\n// Binds the CameraInfo capture signals to the UI visibility signal with Reactive programming\nonScreenInstructions.hidden = hideUi;",
        "super":"Module",
        "methods":[

        ],
        "properties":[
           {
              "name":"previewSize",
              "description":"```\n        (get) previewSize: PixelSizeSignal\n        (set) (Not Available)\n        ```\n\n        Specifies a `PixelSizeSignal` describing the size of the preview, in pixels."
           },
           {
              "name":"effectSafeAreaInsets",
              "description":"```\n        (get) effectSafeAreaInsets: InsetsSignal\n        (set) (Not Available)\n        ```\n\n        Specifies an `InsetsSignal` indicating the insets of the effect safe area."
           },
           {
              "name":"isCapturingPhoto",
              "description":"```\n        (get) isCapturingPhoto: BoolSignal\n        (set) (Not Available)\n        ```\n\n        Specifies a `BoolSignal` that indicates whether the camera is capturing a photo."
           },
           {
              "name":"isRecordingVideo",
              "description":"```\n        (get) isRecordingVideo: BoolSignal\n        (set) (Not Available)\n        ```\n\n        Specifies a `BoolSignal` that indicates whether the camera is recording video."
           },
           {
              "name":"captureDevicePosition",
              "description":"```\n        (get) captureDevicePosition: CameraPosition\n        (set) (Not Available)\n        ```\n\n        Specifies a `CameraPosition` enum value identifying the current camera in use on the device."
           }
        ]
     },
     {
        "name":"ColorPaintMaterial",
        "scope":"MaterialsModule",
        "description":"The `ColorPaintMaterial` class encapsulates a face-paint material.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"backgroundInfluence",
              "description":"```\n(get) backgroundInfluence: ScalarSignal\n(set) backgroundInfluence: ScalarSignal\n```\n\nSpecifies the influence of the background face on the paint texture."
           },
           {
              "name":"paintBrightness",
              "description":"```\n(get) paintBrightness: ScalarValue\n(set) paintBrightness: ScalarSignal\n```\n\nSpecifies the simulated paint brightness."
           }
        ]
     },
     {
        "name":"VectorSignal",
        "scope":"ReactiveModule",
        "description":"The `VectorSignal` class monitors a vector.",
        "super":"ISignal",
        "methods":[
           {
              "name":"delayBy",
              "description":"```\ndelayBy({milliseconds: number}): this\n```\nDelays a signal. The argument is an object with a \"milliseconds\" property specifying the delay duration in milliseconds."
           },
           {
              "name":"distance",
              "description":"```\nPointSignal.distance(other: PointSignal): ScalarSignal\n```\n\nReturns the distance from the point to another point as a `ScalarSignal`."
           },
           {
              "name":"cross",
              "description":"```\nVectorSignal.cross(other: VectorSignal): VectorSignal\n```\n\nReturns a vector signal with the value that is the cross product of the given signals.\n\n**See Also**: `VectorSignal.dot`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"floor",
              "description":"```\nScalarSignal.floor(): ScalarSignal\n```\n\nReturns a signal with the value that is the largest integer that is less than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.floor`"
           },
           {
              "name":"round",
              "description":"```\nScalarSignal.round(): ScalarSignal\n```\n\nReturns a signal with the value that is the rounded value of the given signal.\n\n**Note**: When the fractional part is 0.5, it rounds the number away from zero, which is at odds with JavaScript standard behavior of rounding it always up in such cases. Therefore, this function is NOT exactly the reactive counterpart of the standard JavaScript `Math.round` utility.\n\n**See Also**: `ReactiveModule.round`"
           },
           {
              "name":"smoothStep",
              "description":"```\nReactiveModule.smoothStep(x: ScalarSignal, edge0: ScalarSignal, edge1: ScalarSignal): ScalarSignal\n```\n\nReturns 0.0 if x is less than edge0, and 1.0 if x is greater than edge1.\nIf x is between edge0 and edge1, smooth Hermite interpolation is performed."
           },
           {
              "name":"dot",
              "description":"```\nVectorSignal.dot(other: VectorSignal): ScalarSignal\n```\n\nReturns a scalar signal with the value that is the dot product of the given signals.\n\n**See Also**: `VectorSignal.cross`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"toRange",
              "description":"```\nReactiveModule.toRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [0.0, 1.0] range to [min, max] range."
           },
           {
              "name":"magnitude",
              "description":"```\nVectorSignal.magnitude(): ScalarSignal\n```\n\nReturns the magnitude of the vector as a `ScalarSignal`."
           },
           {
              "name":"atan2",
              "description":"```\nScalarSignal.atan2(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the angle in radians between the x-axis and the ray from (0, 0) to (x, y) where x and y are the values of the specified signals. The range is -PI to +PI.\n\n**See Also**: `ReactiveModule.atan2`"
           },
           {
              "name":"mod",
              "description":"```\nScalarSignal.mod(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the floating-point remainder of the division of the value of the first signal by the value of the second signal.\n\n**See Also**: `ReactiveModule.mod`"
           },
           {
              "name":"sub",
              "description":"```\nScalarSignal.sub(other: ScalarSignal): ScalarSignal\nPointSignal.sub(other: PointSignal): VectorSignal\nPointSignal.sub(other: VectorSignal): PointSignal\nVectorSignal.sub(other: VectorSignal): VectorSignal\n```\n\nReturns a signal with the value that is the difference of the values of the given signals.\n\n**See Also**: `ReactiveModule.sub`, `ScalarSignal.sub`, `VectorSignal.sub`, `PointSignal.sub`"
           },
           {
              "name":"mul",
              "description":"```\nScalarSignal.mul(other: ScalarSignal): ScalarSignal\nScalarSignal.mul(other: VectorSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\nVectorSignal.mul(other: ScalarSignal): VectorSignal\n```\n\nReturns a signal with the value that is the product of the values of the given signals.\n\n**See Also**: `ReactiveModule.mul`, `ScalarSignal.mul`, `VectorSignal.mul`"
           },
           {
              "name":"add",
              "description":"```\nScalarSignal.add(other: ScalarSignal): ScalarSignal\nPointSignal.add(other: VectorSignal): PointSignal\nVectorSignal.add(other: VectorSignal): VectorSignal\nVectorSignal.add(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"reflect",
              "description":"```\nReactiveModule.reflect(incident: VectorSignal, normal: VectorSignal): VectorSignal\nVectorsignal.reflect(normal: VectorSignal): VectorSignal\n```\n\nCalculates the reflection direction for an incident vector and a normal as a `VectorSignal`."
           },
           {
              "name":"pow",
              "description":"```\nScalarSignal.pow(exponent: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the base signal raised to the power of the exponent signal.\n\nRaising a negative base to the power of a fractional exponent produce a NaN.\nRaising 0 to the power of a negative exponent will produce positive infinity.\nRaising 0 to the power of any positive exponent will produce 0.\nRaising -1 to the power of a positive or negative infinity exponent will produce 1.\nRaising 1 to the power of any exponent, including NaN, will produce 1.\nRaising any base, including NaN, to the power of 0 will produce 1.\nRaising any base to the power of negative infinity, where |base| < 1, will produce positive infinity.\nRaising any base to the power of negative infinity, where |base| > 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| < 1, will produce 0.\nRaising any base to the power of positive infinity, where |base| > 1, will produce positive infinity.\nRaising negative infinity to the power of a negative exponent will produce 0.\nRaising negative infinity to the power of a positive exponent will produce positive infinity.\nRaising positive infinity to the power of a negative exponent will produce 0.\nRaising positive infinity to the power of a positive exponent will produce positive infinity.\n\nIn all other cases, if either the base or the exponent is a NaN, a NaN will be produced.\n\n**See Also**: `ReactiveModule.pow`"
           },
           {
              "name":"sum",
              "description":"```\nScalarSignal.sum(other: ScalarSignal): ScalarSignal\nPointSignal.sum(other: VectorSignal): PointSignal\nVectorSignal.sum(other: VectorSignal): VectorSignal\nVectorSignal.sum(other: PointSignal): PointSignal\n```\n\nReturns a signal with the value that is the sum of the values of the given signals.\n\n**Note**: `add` and `sum` functions are synonyms, the behavior they provide is equivalent.\n\n**See Also**: `ScalarSignal.sum`, ReactiveModule.add`"
           },
           {
              "name":"sign",
              "description":"```\nScalarSignal.sign(): ScalarSignal\n```\n\nReturns a signal with the value that is the sign of the given signal. Possible sign values: NaN, -0.0, 0.0, -1.0, 1.0.\n\n**Note**: this function is the reactive counterpart of the standard JavaScript `Math.sign` utility.\n\n**See Also**: `ReactiveModule.sign`"
           },
           {
              "name":"div",
              "description":"```\nScalarSignal.div(other: ScalarSignal): ScalarSignal\n```\n\nReturns a signal with the value that is the value of the first signal divided by the value of the second signal.\n\n**See Also**: `ReactiveModule.div`"
           },
           {
              "name":"sqrt",
              "description":"```\nScalarSignal.sqrt(): ScalarSignal\n```\n\nReturns a signal with the value that is the square root of the value of the given signal.\n\n**See Also**: `ReactiveModule.sqrt`"
           },
           {
              "name":"fromRange",
              "description":"```\nReactiveModule.fromRange(x: ScalarSignal, min: ScalarSignal, max: ScalarSignal): ScalarSignal\n```\n\nMaps x from [min, max] range to [0.0, 1.0] range."
           },
           {
              "name":"abs",
              "description":"```\nScalarSignal.abs(): ScalarSignal\n```\n\nReturns a signal with the value that is the absolute value of the given signal.\n\n**See Also**: `ReactiveModule.abs`"
           },
           {
              "name":"neg",
              "description":"```\nScalarSignal.neg(): ScalarSignal\nVectorSignal.neg(): VectorSignal\n```\n\nReturns a signal with the negated value of the given signal.\n\n**See Also**: `ReactiveModule.neg`, `ScalarSignal.neg`, `VectorSignal.neg`"
           },
           {
              "name":"ceil",
              "description":"```\nScalarSignal.ceil(): ScalarSignal\n```\n\nReturns a signal with the value that is the smallest integer that is greater than or equal to the value of the given signal.\n\n**See Also**: `ReactiveModule.ceil`"
           },
           {
              "name":"normalize",
              "description":"```\nReactiveModule.normalize(v: VectorSignal): VectorSignal\nVectorsignal.normalize(): VectorSignal\n```\n\nReturns the normalized (unit) vector in the direction of the original vector as a `VectorSignal`."
           },
           {
              "name":"expSmooth",
              "description":"```\nexpSmooth(dampFactor: number): VectorSignal\n```\n\nSmoothes a variable signal using exponential averaging over time. The argument specifies the dampening time constant in milliseconds.\n\n**Note**: See also `ReactiveModule.expSmooth`."
           }
        ],
        "properties":[
           {
              "name":"z",
              "description":"```\n(get) z: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Z component of the vector."
           },
           {
              "name":"y",
              "description":"```\n(get) y: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the Y component of the vector."
           },
           {
              "name":"x",
              "description":"```\n(get) x: ScalarSignal\n(set) (Not Available)\n```\n\nRepresents the X component of the vector."
           }
        ]
     },
     {
        "name":"FontId",
        "scope":"FontsModule",
        "description":"The `FontsId` class identifies a font in an effect.",
        "methods":[

        ],
        "properties":[
           {
              "name":"name",
              "description":"```\n(get) name: String\n(set) (Not Available)\n```\n\nSpecifies the font name. It should be unique.\n\n**See Also**: `FontsModule.get`."
           }
        ]
     },
     {
        "name":"DeviceMotionModule",
        "description":"The `DeviceMotionModule` class enables device movement detection.",
        "exampleCode":"const Reactive = require('Reactive');\nconst DeviceMotion = require('DeviceMotion');\nconst Scene = require('Scene');\n\nvar boundPlane = Scene.root.child('Device').child('Camera').child('Focal Distance').child('boundPlane');\n\nboundPlane.transform.rotationX = DeviceMotion.worldTransform.rotationX;\nboundPlane.transform.rotationY = DeviceMotion.worldTransform.rotationY;\nboundPlane.transform.rotationZ = DeviceMotion.worldTransform.rotationZ;",
        "super":"Module",
        "methods":[

        ],
        "properties":[
           {
              "name":"worldTransform",
              "description":"```\n                       (get) worldTransform: TransformSignal\n                       (set) (Not Available)\n                       ```\n\n                       Specifies a `TransformSignal` representing the device transformation relative to world coordinate system."
           }
        ]
     },
     {
        "name":"MetallicRoughnessPbrMaterial",
        "scope":"MaterialsModule",
        "description":"The `MetallicRoughnessPbrMaterial` class encapsulates physically based materials.",
        "super":"MaterialBase",
        "methods":[

        ],
        "properties":[
           {
              "name":"metallicRoughness",
              "description":"```\n(get) (Not Available)\n(set) reflective: TextureBase\n```\n\nSpecifies the metallicRoughness texture of the material."
           },
           {
              "name":"metallicRoughnessTextureTransform",
              "description":"```\n(get) transform: TextureTransform\n(set) transform: TextureTransformSignal\n```\n\nSpecifies the coordinates transform of the metallicRoughness texture of this material."
           },
           {
              "name":"baseColorTextureTransform",
              "description":"```\n(get) transform: TextureTransform\n(set) transform: TextureTransformSignal\n```\n\nSpecifies the coordinates transform of the baseColorFactor texture of this material."
           },
           {
              "name":"baseColor",
              "description":"```\n(get) (Not Available)\n(set) reflective: TextureBase\n```\n\nSpecifies the baseColor texture of the material."
           },
           {
              "name":"roughnessFactor",
              "description":"```\n(get) roughnessFactor: ScalarSignal\n(set) roughnessFactor: ScalarSignal\n```\nSpecifies the roughness factor."
           },
           {
              "name":"baseColorFactor",
              "description":"```\n(get) color: (Not Available)\n(set) color: ColorSignal\n```\nSpecifies a `ColorSignal` for a base color factor. A `ColorSignal` may be created using the `RGBA()` and `HSVA()` methods of the `Reactive` module.\n**See Also**: `ReactiveModule.RGBA` and `ReactiveModule.HSVA`."
           },
           {
              "name":"emissiveTextureTransform",
              "description":"```\n(get) transform: TextureTransform\n(set) transform: TextureTransformSignal\n```\n\nSpecifies the coordinates transform of the emissive texture of this material."
           },
           {
              "name":"metallicFactor",
              "description":"```\n(get) metallicFactor: ScalarSignal\n(set) metallicFactor: ScalarSignal\n ```\nSpecifies the metallic factor."
           },
           {
              "name":"emissive",
              "description":"```\n(get) emissive: TextureBase\n(set) emissive: TextureBase\n```\n\nSpecifies the emissive texture of the material."
           }
        ]
     },
     {
        "name":"FontsModule",
        "description":"The `FontsModule` class is used for working with custom fonts in effects.",
        "super":"Module",
        "methods":[
           {
              "name":"get",
              "description":"```\nget(fontName: string): Font\n```\n\nReturns a font object identified by the `fontName` argument.\n\nThrows an exception if there is no such font in the project."
           }
        ],
        "properties":[

        ]
     }
  ]
}
